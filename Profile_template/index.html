<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">

    <!-- /// META TIÊU ĐỀ & MÔ TẢ /// -->
    <title>Niyaki Pham | Profile Sci-Fi: Nhạc (MP3 &amp; YouTube), To-Do &amp; Anime</title>
    <meta name="description"
        content="Profile cá nhân độc đáo của Niyaki Phạm: Nghe nhạc MP3/YouTube, quản lý To-Do list hẹn giờ và khám phá thế giới Anime.">
    <meta name="author" content="THB">

    <!-- /// META TỪ KHÓA SEO /// -->
    <meta name="keywords"
        content="Niyaki Phạm, Niyaki Pham, Phạm Văn Hoàng, Profile cá nhân, Porfolio, Web Developer, Phát nhạc YouTube, YouTube Player API, Music Player, Audio Player, Autoplay music, Real-time Clock, To-Do List, Quản lý công việc, Notification API, Anime Search, Tìm kiếm Anime, Xem Anime Online, Sci-fi profile, Media Session API">
    <meta name="robots" content="index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1">
    <meta name="googlebot" content="index, follow">

    <!-- /// META CANONICAL URL /// -->
    <link rel="canonical" href="https://niyakipham.github.io/">
    <!-- !! Quan trọng: Thay bằng URL chính thức của bạn !! -->

    <!-- /// META ICON (FAVICON) /// -->
    <link rel="icon" href="https://niyakipham.github.io/assets/kaguya.jpeg" type="image/jpeg">
    <link rel="apple-touch-icon" href="https://niyakipham.github.io/assets/kaguya.jpeg">

    <!-- /// META OPEN GRAPH (Bổ sung og:image để Media Session sử dụng) /// -->
    <meta property="og:title" content="Niyaki Phạm - Profile Sci-Fi: Nhạc MP3/YouTube, To-Do & Tìm Anime">
    <meta property="og:description"
        content="Khám phá profile Niyaki Phạm: Playlist nhạc MP3 và YouTube tự động, To-Do list hẹn giờ và công cụ tìm kiếm, xem anime tiện lợi.">
    <meta property="og:type" content="profile">
    <meta property="og:url" content="https://niyakipham.github.io/">
    <!-- !! Quan trọng: Thay bằng URL chính thức của bạn !! -->
    <meta property="og:image" content="https://niyakipham.github.io/assets/kaguya.jpeg">
    <!-- !! Quan trọng cho Media Session -->
    <meta property="og:image:alt" content="Ảnh đại diện của Niyaki Phạm">
    <meta property="og:locale" content="vi_VN">
    <meta property="profile:username" content="niyakipham">

    <!-- /// META TWITTER CARD /// -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Niyaki Phạm - Profile: Nhạc (MP3/YouTube), To-Do & Anime">
    <meta name="twitter:description"
        content="Kết nối Niyaki Phạm! Nghe nhạc MP3/YouTube, quản lý công việc, tìm và xem anime yêu thích ngay trên profile độc đáo này.">
    <meta name="twitter:image" content="https://niyakipham.github.io/assets/kaguya.jpeg">
    <meta name="twitter:site" content="@niyakipham"> <!-- Thay nếu có -->
    <meta name="twitter:creator" content="@niyakipham"> <!-- Thay nếu có -->

    <!-- /// GOOGLE FONTS /// -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;700&family=Orbitron:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- /// IONICONS /// -->
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js" defer></script>
    <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js" defer></script>

    <!-- /// ANIME.JS /// -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <style>
        /* === CSS RESET & BASE STYLES === */
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --color-bg-dark: #0a0a0a;
            --color-primary: #e11d48;
            --color-secondary: #f43f5e;
            --color-accent: #f87171;
            --color-text-primary: #f1f1f1;
            --color-text-secondary: #a1a1a1;
            --color-primary-rgb: 225, 29, 72;
            /* Will be set by JS */
            --color-glitch-1: #00ffff;
            --color-glitch-2: #ff00ff;
            --font-primary: 'Inter', sans-serif;
            --font-secondary: 'Orbitron', sans-serif;
            --grid-size: 30px;
            --grid-line-color: rgba(var(--color-primary-rgb), 0.08);
            --grid-line-width: 1px;
            --transition-speed-fast: 0.2s;
            --transition-speed-normal: 0.4s;
            --border-radius-sm: 4px;
            --border-radius-md: 8px;
            --border-radius-lg: 16px;
            --border-radius-circle: 50%;
            --space-xxs: 0.25rem;
            --space-xs: 0.5rem;
            --space-sm: 0.85rem;
            --space-md: 1.25rem;
            --space-lg: 2rem;
        }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-primary);
            color: var(--color-text-primary);
            background-color: var(--color-bg-dark);
            background-image: linear-gradient(to right, var(--grid-line-color) var(--grid-line-width), transparent var(--grid-line-width)), linear-gradient(to bottom, var(--grid-line-color) var(--grid-line-width), transparent var(--grid-line-width));
            background-size: var(--grid-size) var(--grid-size);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: var(--space-sm);
            overflow-x: hidden;
            position: relative;
            line-height: 1.6;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4" viewBox="0 0 4 4"><path fill="%23cccccc" fill-opacity="0.02" d="M0 0h2v2H0zM2 2h2v2H0z"></path></svg>');
            opacity: 0.6;
            pointer-events: none;
            z-index: -1;
            animation: scanlines 15s linear infinite;
        }

        @keyframes scanlines {
            0% {
                background-position: 0 0;
            }

            100% {
                background-position: 0 150px;
            }
        }

        /* === MAIN CONTAINER === */
        #container {
            background-color: rgba(16, 16, 16, 0.7);
            backdrop-filter: blur(12px) saturate(180%);
            -webkit-backdrop-filter: blur(12px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--border-radius-lg);
            padding: var(--space-md);
            max-width: 480px;
            width: 100%;
            text-align: center;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.6), inset 0 0 20px rgba(var(--color-primary-rgb), 0.15);
            position: relative;
            overflow: hidden;
            transform-style: preserve-3d;
            opacity: 0;
            transform: translateY(20px);
            /* Animation Start */
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        /* === PROFILE SECTION === */
        #profile {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #profile-image-wrapper {
            position: relative;
            width: 100px;
            height: 100px;
            margin-bottom: var(--space-xs);
        }

        #profile-image-wrapper::before {
            content: '';
            position: absolute;
            inset: -4px;
            border-radius: var(--border-radius-circle);
            background: conic-gradient(from 90deg, transparent 0%, var(--color-secondary) 25%, var(--color-primary) 50%, var(--color-secondary) 75%, transparent 100%);
            filter: blur(12px);
            z-index: -1;
            animation: rotateGlow 5s linear infinite;
            opacity: 0.7;
        }

        @keyframes rotateGlow {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        #profile img#avatar {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: var(--border-radius-circle);
            border: 2px solid var(--color-primary);
            padding: 2px;
            background-color: var(--color-bg-dark);
            transition: transform var(--transition-speed-normal) ease, box-shadow var(--transition-speed-normal) ease;
            cursor: pointer;
            position: relative;
            z-index: 1;
        }

        #profile img#avatar:hover {
            transform: scale(1.05) rotate(2deg);
            box-shadow: 0 0 15px var(--color-primary);
        }

        #profile p#username {
            font-weight: 500;
            font-size: 1.05rem;
            color: var(--color-text-primary);
            margin-top: var(--space-xxs);
            font-family: var(--font-secondary);
            letter-spacing: 1px;
            text-shadow: 0 0 4px var(--color-secondary), 1px 1px 1px rgba(0, 0, 0, 0.5);
            margin-bottom: var(--space-xxs);
        }

        .glitch-text {
            position: relative;
            text-shadow: 0.05em 0 0 var(--color-glitch-1), -0.025em -0.05em 0 var(--color-glitch-2), 0.025em 0.05em 0 var(--color-glitch-1);
            animation: glitchAnim 0.5s infinite alternate;
        }

        @keyframes glitchAnim {
            0% {
                text-shadow: .05em 0 0 var(--color-glitch-1), -.05em -.025em 0 var(--color-glitch-2), -.025em .05em 0 var(--color-glitch-1)
            }

            25% {
                -0.05em -0.025em 0 var(--color-glitch-1),
                .025em .025em 0 var(--color-glitch-2),
                -0.05em -0.05em 0 var(--color-glitch-1)
            }

            50% {
                text-shadow: .025em .05em 0 var(--color-glitch-1), .05em 0 0 var(--color-glitch-2), 0 -.05em 0 var(--color-glitch-1)
            }

            75% {
                text-shadow: -.05em 0 0 var(--color-glitch-1), -.025em -.025em 0 var(--color-glitch-2), -.025em -.05em 0 var(--color-glitch-1)
            }

            100% {
                text-shadow: -.025em 0 0 var(--color-glitch-1), .025em -.025em 0 var(--color-glitch-2), .05em .05em 0 var(--color-glitch-1)
            }
        }

        /* === CLOCK STYLES === */
        #clock {
            font-family: var(--font-secondary);
            font-size: 0.85rem;
            color: var(--color-text-secondary);
            letter-spacing: 1.5px;
            opacity: 0;
            transform: translateY(10px);
            /* Animation */
            text-shadow: 0 0 3px rgba(var(--color-primary-rgb), 0.3);
            margin-bottom: 0;
        }

        /* === TO-DO LIST STYLES === */
        #todo-section {
            border-top: 1px solid rgba(var(--color-primary-rgb), 0.15);
            padding-top: var(--space-sm);
            opacity: 0;
            transform: translateY(20px);
            /* Animation */
        }

        .sci-fi-heading {
            font-family: var(--font-secondary);
            font-size: 1rem;
            color: var(--color-primary);
            text-align: center;
            margin-bottom: var(--space-xs);
            letter-spacing: 0.5px;
            text-shadow: 0 0 4px rgba(var(--color-primary-rgb), 0.4);
        }

        #todo-form {
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
            margin-bottom: var(--space-sm);
        }

        #todo-form .todo-input-group {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
        }

        #todo-form input[type="text"],
        #todo-form input[type="time"] {
            flex-grow: 1;
            padding: var(--space-xs) var(--space-sm);
            background-color: rgba(var(--color-primary-rgb), 0.05);
            border: 1px solid rgba(var(--color-primary-rgb), 0.25);
            border-radius: var(--border-radius-sm);
            color: var(--color-text-primary);
            font-family: var(--font-primary);
            font-size: 0.85rem;
            min-width: 100px;
        }

        #todo-form input[type="time"] {
            flex-basis: 100px;
            flex-grow: 0;
            appearance: none;
            -webkit-appearance: none;
        }

        #todo-form input[type="time"]::-webkit-calendar-picker-indicator {
            display: none;
        }

        #todo-form input[type="time"]::-webkit-datetime-edit-ampm-field {
            color: var(--color-accent);
        }

        #todo-form input[type="time"]::-webkit-datetime-edit-hour-field,
        #todo-form input[type="time"]::-webkit-datetime-edit-minute-field {
            color: var(--color-text-primary);
        }

        #todo-form input::placeholder {
            color: var(--color-text-secondary);
            opacity: 0.7;
        }

        #add-todo-btn,
        #request-permission-btn {
            padding: var(--space-xs) var(--space-sm);
            background-color: rgba(var(--color-primary-rgb), 0.2);
            border: 1px solid var(--color-primary);
            color: var(--color-primary);
            font-family: var(--font-secondary);
            font-weight: 500;
            font-size: 0.9rem;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: all var(--transition-speed-fast) ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xxs);
            align-self: flex-start;
            height: 36px;
        }

        #add-todo-btn ion-icon {
            font-size: 1.1em;
        }

        #add-todo-btn:hover,
        #request-permission-btn:hover {
            background-color: var(--color-primary);
            color: var(--color-bg-dark);
            box-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.4);
        }

        #request-permission-btn {
            display: none;
            margin-top: var(--space-xs);
        }

        #todo-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-height: 160px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--color-primary) rgba(var(--color-primary-rgb), 0.1);
        }

        #todo-list::-webkit-scrollbar {
            width: 5px;
        }

        #todo-list::-webkit-scrollbar-track {
            background: rgba(var(--color-primary-rgb), 0.08);
            border-radius: 3px;
        }

        #todo-list::-webkit-scrollbar-thumb {
            background-color: var(--color-primary);
            border-radius: 3px;
            border: 1px solid rgba(var(--color-primary-rgb), 0.2);
        }

        #todo-list li {
            background-color: rgba(255, 255, 255, 0.02);
            border-left: 3px solid var(--color-primary);
            padding: var(--space-xs) var(--space-sm);
            margin-bottom: var(--space-xs);
            border-radius: var(--border-radius-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: var(--space-sm);
            /*opacity: 0; transform: translateX(-10px);  Animation managed by JS now */
            transition: background-color var(--transition-speed-fast), opacity 0.3s ease, transform 0.3s ease, border-left-color var(--transition-speed-fast);
        }

        #todo-list li.completed {
            border-left-color: var(--color-text-secondary);
            opacity: 0.5;
        }

        #todo-list li.completed .todo-text {
            text-decoration: line-through;
            color: var(--color-text-secondary);
        }

        #todo-list .todo-content {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            overflow: hidden;
            word-break: break-word;
        }

        #todo-list .todo-text {
            color: var(--color-text-primary);
            font-size: 0.9rem;
        }

        #todo-list .todo-time-info {
            font-size: 0.7rem;
            color: var(--color-text-secondary);
            margin-top: 2px;
            display: flex;
            align-items: center;
            gap: 4px;
            flex-wrap: wrap;
        }

        #todo-list .todo-time-info ion-icon {
            font-size: 0.85em;
        }

        #todo-list .todo-time-info ion-icon[name="alarm-outline"] {
            color: var(--color-accent);
        }

        #todo-list .todo-time-info ion-icon[name="checkmark-done-outline"] {
            color: var(--color-primary);
        }

        #todo-list .todo-actions {
            display: flex;
            gap: var(--space-xxs);
            flex-shrink: 0;
        }

        #todo-list .todo-actions button {
            background: none;
            border: none;
            color: var(--color-text-secondary);
            font-size: 1.2rem;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            transition: color var(--transition-speed-fast), background-color var(--transition-speed-fast);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #todo-list .todo-actions button.delete-btn:hover {
            color: #ff4d4d;
            background-color: rgba(255, 77, 77, 0.1);
        }

        #todo-list .todo-actions button.complete-btn:hover {
            color: #4caf50;
            background-color: rgba(76, 175, 80, 0.1);
        }

        #todo-list li.completed .todo-actions button.complete-btn {
            color: #4caf50;
        }

        /* === AUDIO PLAYER === */
        #audio-player {
            background-color: rgba(var(--color-primary-rgb), 0.05);
            border: 1px solid rgba(var(--color-primary-rgb), 0.2);
            border-radius: var(--border-radius-md);
            padding: var(--space-sm);
            opacity: 0;
            transform: translateY(10px);
            /* Animation */
            box-shadow: inset 0 1px 5px rgba(var(--color-primary-rgb), 0.1);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            position: relative;
            /* Added */
        }

        #audio-player .track-info {
            width: 100%;
            text-align: left;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        #audio-player #track-title {
            display: block;
            font-size: 0.95rem;
            color: var(--color-text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-family: var(--font-secondary);
            letter-spacing: 0.5px;
            padding: 0 var(--space-xs);
            min-height: 1.2em;
            line-height: 1.3;
        }

        #audio-player #track-title.is-youtube::before {
            content: '';
            display: inline-block;
            width: 14px;
            height: 10px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 11.2" fill="%23FF0000"><path d="M15.7.9A2 2 0 0014.1 0H1.9A2 2 0 00.3.9 22.6 22.6 0 000 5.6a22.6 22.6 0 00.3 4.7 2 2 0 001.6.9h12.2a2 2 0 001.6-.9 22.6 22.6 0 00.3-4.7 22.6 22.6 0 00-.3-4.7zM6.4 8V3.2l4.6 2.4-4.6 2.4z"/></svg>');
            background-repeat: no-repeat;
            background-size: contain;
            margin-right: 5px;
            vertical-align: baseline;
        }

        #audio-player .progress-container {
            width: 100%;
            height: 8px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(var(--color-primary-rgb), 0.1);
        }

        #audio-player #progress-bar {
            width: 0%;
            height: 100%;
            background-color: var(--color-primary);
            border-radius: var(--border-radius-sm);
            transition: width 0.1s linear;
            box-shadow: 0 0 8px 1px var(--color-primary);
        }

        #audio-player .controls {
            width: 100%;
            display: flex;
            justify-content: center;
            /* Centered controls */
            align-items: center;
            gap: var(--space-md);
            padding: 0 var(--space-xs);
        }

        #audio-player .controls .main-controls {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }

        #audio-player .controls button {
            background: none;
            border: none;
            color: var(--color-text-secondary);
            font-size: 1.6rem;
            cursor: pointer;
            padding: var(--space-xs);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color var(--transition-speed-fast) ease, transform var(--transition-speed-fast) ease, background-color var(--transition-speed-fast) ease;
            line-height: 1;
            border-radius: var(--border-radius-circle);
        }

        #audio-player .controls button:hover,
        #audio-player .controls button:focus {
            color: var(--color-secondary);
            transform: scale(1.1);
            outline: none;
            background-color: rgba(var(--color-primary-rgb), 0.1);
        }

        #audio-player .controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            background-color: transparent;
        }

        #audio-player .controls button ion-icon {
            display: block;
        }

        #audio-player button#play-pause-btn {
            font-size: 2.4rem;
            color: var(--color-secondary);
        }

        #audio-player button#play-pause-btn:hover,
        #audio-player button#play-pause-btn:focus {
            color: var(--color-primary);
            background-color: rgba(var(--color-primary-rgb), 0.15);
        }

        /* === YouTube Player Container (Hidden) === */
        #youtube-player-container {
            position: absolute;
            /* Place it far off-screen */
            top: -9999px;
            left: -9999px;
            width: 1px;
            /* Minimal size */
            height: 1px;
            opacity: 0;
            /* Completely invisible */
            pointer-events: none;
            /* No interaction */
            /* Overflow hidden to ensure nothing bleeds out */
            overflow: hidden;
        }

        /* === ANIME SEARCH SECTION STYLES === */
        #anime-search-section {
            border-top: 1px solid rgba(var(--color-primary-rgb), 0.15);
            padding-top: var(--space-sm);
            margin-top: var(--space-sm);
            opacity: 0;
            transform: translateY(20px);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        #search-wrapper {
            display: flex;
            gap: var(--space-xs);
            position: relative;
        }

        #anime-search-input {
            flex-grow: 1;
            padding: var(--space-xs) var(--space-sm);
            padding-right: 40px;
            background-color: rgba(var(--color-primary-rgb), 0.05);
            border: 1px solid rgba(var(--color-primary-rgb), 0.25);
            border-radius: var(--border-radius-sm);
            color: var(--color-text-primary);
            font-family: var(--font-primary);
            font-size: 0.9rem;
            transition: border-color var(--transition-speed-fast), box-shadow var(--transition-speed-fast);
        }

        #anime-search-input:focus {
            outline: none;
            border-color: var(--color-primary);
            box-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.3);
        }

        #anime-search-input::placeholder {
            color: var(--color-text-secondary);
            opacity: 0.7;
        }

        #anime-search-input:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        #anime-search-input::-webkit-search-cancel-button,
        #anime-search-input::-webkit-search-decoration {
            -webkit-appearance: none;
            appearance: none;
        }

        #search-button {
            position: absolute;
            right: 1px;
            top: 1px;
            bottom: 1px;
            background: none;
            border: none;
            color: var(--color-text-secondary);
            font-size: 1.4rem;
            cursor: pointer;
            padding: 0 var(--space-xs);
            border-radius: 0 var(--border-radius-sm) var(--border-radius-sm) 0;
            transition: color var(--transition-speed-fast);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #search-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            color: var(--color-text-secondary) !important;
        }

        #search-button:not(:disabled):hover {
            color: var(--color-primary);
        }

        #anime-results-container,
        #anime-episode-list-container {
            background-color: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(var(--color-primary-rgb), 0.1);
            border-radius: var(--border-radius-md);
            padding: var(--space-sm);
            min-height: 60px;
            max-height: 250px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: var(--color-primary) rgba(var(--color-primary-rgb), 0.1);
            transition: all 0.3s ease;
        }

        #anime-results-container::-webkit-scrollbar,
        #anime-episode-list-container::-webkit-scrollbar {
            width: 5px;
        }

        #anime-results-container::-webkit-scrollbar-track,
        #anime-episode-list-container::-webkit-scrollbar-track {
            background: rgba(var(--color-primary-rgb), 0.08);
            border-radius: 3px;
        }

        #anime-results-container::-webkit-scrollbar-thumb,
        #anime-episode-list-container::-webkit-scrollbar-thumb {
            background-color: var(--color-primary);
            border-radius: 3px;
            border: 1px solid rgba(var(--color-primary-rgb), 0.2);
        }

        #anime-episode-list-container {
            display: none;
            flex-direction: column;
            gap: var(--space-xs);
        }

        #episode-list-heading {
            margin-bottom: var(--space-xs);
            padding-bottom: var(--space-xs);
            border-bottom: 1px dashed rgba(var(--color-primary-rgb), 0.2);
            text-align: left;
        }

        #anime-episode-list {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: var(--space-xs);
        }

        .search-result-item,
        .episode-item {
            background-color: rgba(var(--color-primary-rgb), 0.08);
            border-left: 3px solid var(--color-accent);
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: all var(--transition-speed-fast) ease;
            font-size: 0.9rem;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            text-align: left;
        }

        .episode-item[style*="cursor: not-allowed"] {
            border-left-color: var(--color-text-secondary);
        }

        .search-result-item:hover,
        .episode-item:not([style*="cursor: not-allowed"]):hover,
        .search-result-item:focus,
        .episode-item:not([style*="cursor: not-allowed"]):focus {
            background-color: rgba(var(--color-primary-rgb), 0.2);
            border-left-color: var(--color-primary);
            transform: translateX(4px);
            outline: none;
            box-shadow: 0 0 5px rgba(var(--color-primary-rgb), 0.3);
        }

        .placeholder-text {
            color: var(--color-text-secondary);
            text-align: center;
            padding: var(--space-sm);
            font-style: italic;
            font-size: 0.9rem;
        }

        .placeholder-text.error {
            color: var(--color-accent);
            font-style: normal;
        }

        #back-to-search-btn {
            padding: var(--space-xs) var(--space-sm);
            background-color: rgba(var(--color-primary-rgb), 0.1);
            border: 1px solid rgba(var(--color-primary-rgb), 0.5);
            color: var(--color-primary);
            font-family: var(--font-secondary);
            font-weight: 500;
            font-size: 0.85rem;
            border-radius: var(--border-radius-sm);
            cursor: pointer;
            transition: all var(--transition-speed-fast) ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-xxs);
            align-self: flex-start;
            margin-top: var(--space-sm);
        }

        #back-to-search-btn ion-icon {
            font-size: 1.1em;
        }

        #back-to-search-btn:hover,
        #back-to-search-btn:focus {
            background-color: var(--color-primary);
            color: var(--color-bg-dark);
            box-shadow: 0 0 8px rgba(var(--color-primary-rgb), 0.4);
            outline: none;
        }

        /* === IFRAME PLAYER CONTAINER (Anime Viewer) === */
        #anime-player-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 90%;
            max-width: 800px;
            background-color: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(15px) saturate(190%);
            -webkit-backdrop-filter: blur(15px) saturate(190%);
            border: 1px solid rgba(var(--color-primary-rgb), 0.3);
            border-radius: var(--border-radius-lg);
            padding: var(--space-md);
            z-index: 1000;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            will-change: opacity, transform;
            visibility: hidden;
        }

        #anime-player-container.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            visibility: visible;
        }

        #player-anime-title {
            font-family: var(--font-secondary);
            color: var(--color-primary);
            text-align: center;
            font-size: 1rem;
            margin: 0;
            padding-bottom: var(--space-xs);
            border-bottom: 1px solid rgba(var(--color-primary-rgb), 0.2);
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        .iframe-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%;
            height: 0;
            background-color: #000;
            border-radius: var(--border-radius-sm);
            overflow: hidden;
            border: 1px solid rgba(var(--color-primary-rgb), 0.1);
        }

        #anime-iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        #close-player-btn {
            position: absolute;
            top: var(--space-xs);
            right: var(--space-xs);
            background: none;
            border: none;
            color: var(--color-text-secondary);
            font-size: 1.8rem;
            cursor: pointer;
            padding: 2px;
            line-height: 1;
            transition: color var(--transition-speed-fast), transform var(--transition-speed-fast);
            border-radius: 50%;
            z-index: 10;
        }

        #close-player-btn:hover,
        #close-player-btn:focus {
            color: var(--color-primary);
            transform: rotate(90deg);
            outline: none;
        }

        /* Overlay when player is open */
        body.player-open::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
            z-index: 999;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: all;
            visibility: hidden;
        }

        body.player-open::after {
            opacity: 1;
            visibility: visible;
        }

        /* === LINKS LIST === */
        #links {
            border-top: 1px solid rgba(var(--color-primary-rgb), 0.15);
            padding-top: var(--space-sm);
            margin-top: var(--space-sm);
        }

        #links ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: var(--space-sm);
        }

        #links li {
            opacity: 0;
            transform: translateX(-20px);
            /* Animation */
        }

        #links a {
            display: block;
            padding: var(--space-sm) var(--space-md);
            text-decoration: none;
            color: var(--color-text-primary);
            background-color: rgba(var(--color-primary-rgb), 0.1);
            border: 1px solid rgba(var(--color-primary-rgb), 0.5);
            border-radius: var(--border-radius-sm);
            font-weight: 500;
            transition: all var(--transition-speed-fast) ease-out;
            position: relative;
            overflow: hidden;
            z-index: 1;
            will-change: transform, background-color, box-shadow;
            text-align: center;
        }

        #links a::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(var(--color-primary-rgb), 0.4), transparent);
            transition: left var(--transition-speed-normal) ease-out;
            z-index: -1;
        }

        #links a:hover,
        #links a:focus {
            background-color: rgba(var(--color-primary-rgb), 0.25);
            border-color: var(--color-primary);
            color: #fff;
            transform: scale(1.03);
            box-shadow: 0 0 15px rgba(var(--color-primary-rgb), 0.4);
            outline: none;
        }

        #links a:hover::before,
        #links a:focus::before {
            left: 100%;
        }

        #links a:active {
            transform: scale(0.98);
            background-color: rgba(var(--color-primary-rgb), 0.3);
        }

        /* === SOCIAL LINKS === */
        #social-links {
            display: flex;
            justify-content: center;
            gap: var(--space-md);
            padding-top: var(--space-sm);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            opacity: 0;
            transform: translateY(20px);
            /* Animation */
        }

        #social-links a {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--color-text-secondary);
            font-size: 1.6rem;
            width: 40px;
            height: 40px;
            border-radius: var(--border-radius-circle);
            text-decoration: none;
            transition: all var(--transition-speed-fast) ease;
            will-change: transform, color, background-color;
        }

        #social-links a:hover,
        #social-links a:focus {
            color: var(--color-primary);
            transform: translateY(-3px) scale(1.1);
            outline: none;
            background-color: rgba(var(--color-primary-rgb), 0.1);
        }

        #social-links ion-icon {
            display: block;
        }

        /* === FOOTER === */
        footer {
            margin-top: var(--space-xs);
            font-size: 0.8rem;
            color: var(--color-text-secondary);
            opacity: 0;
            transform: translateY(20px);
            /* Animation */
            text-align: center;
        }

        footer a {
            color: var(--color-accent);
            text-decoration: none;
            font-weight: 500;
            transition: color var(--transition-speed-fast) ease, text-shadow var(--transition-speed-fast) ease;
        }

        footer a:hover,
        footer a:focus {
            color: var(--color-secondary);
            text-shadow: 0 0 5px var(--color-secondary);
            outline: none;
        }

        /* === RESPONSIVENESS === */
        @media (min-width: 500px) {
            #todo-form {
                flex-direction: row;
                align-items: center;
            }

            #todo-form input[type="text"] {
                max-width: none;
            }

            #todo-form input[type="time"] {
                flex-basis: 100px;
            }

            #add-todo-btn {
                align-self: center;
            }
        }

        @media (max-width: 768px) {
            :root {
                --space-lg: 1.8rem;
                --space-md: 1.1rem;
                --space-sm: 0.75rem;
            }

            #container {
                padding: var(--space-md);
                margin: var(--space-sm);
                gap: var(--space-sm);
            }

            #profile-image-wrapper {
                width: 90px;
                height: 90px;
            }

            #clock {
                font-size: 0.8rem;
            }

            #audio-player {
                padding: var(--space-xs);
            }

            #audio-player #track-title {
                font-size: 0.9rem;
            }

            #audio-player .controls {
                gap: var(--space-sm);
            }

            #audio-player .controls button {
                font-size: 1.5rem;
            }

            #audio-player button#play-pause-btn {
                font-size: 2.2rem;
            }

            #social-links {
                gap: var(--space-sm);
            }

            #social-links a {
                font-size: 1.5rem;
                width: 38px;
                height: 38px;
            }

            #anime-results-container,
            #anime-episode-list-container {
                max-height: 200px;
            }
        }

        @media (max-width: 420px) {
            :root {
                --space-md: 1rem;
                --space-sm: 0.65rem;
            }

            #profile-image-wrapper {
                width: 80px;
                height: 80px;
            }

            #clock {
                letter-spacing: 1px;
            }

            #audio-player #track-title {
                font-size: 0.85rem;
            }

            #audio-player .controls {
                gap: var(--space-xs);
            }

            #audio-player .controls button {
                font-size: 1.4rem;
                padding: calc(var(--space-xs) / 2);
            }

            #audio-player button#play-pause-btn {
                font-size: 2rem;
            }

            #social-links {
                gap: var(--space-xs);
            }

            #social-links a {
                font-size: 1.4rem;
                width: 34px;
                height: 34px;
            }

            #links a {
                padding: var(--space-sm);
            }

            #todo-list li {
                flex-direction: column;
                align-items: flex-start;
            }

            #todo-list .todo-actions {
                margin-top: var(--space-xs);
                align-self: flex-end;
            }

            #todo-form .todo-input-group {
                flex-direction: column;
            }

            #todo-form input[type="time"] {
                flex-basis: auto;
                width: 100%;
            }

            #add-todo-btn {
                width: 100%;
                margin-top: var(--space-xs);
            }

            #anime-results-container,
            #anime-episode-list-container {
                max-height: 180px;
            }

            .search-result-item,
            .episode-item {
                font-size: 0.85rem;
            }
        }

        /* === UTILITY CLASSES === */
        .visually-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>

<body>

    <div id="container">
        <div id="profile">
            <div id="profile-image-wrapper">
                <img id="avatar" src="https://niyakipham.github.io/assets/kaguya.jpeg"
                    alt="Ảnh đại diện anime của Niyaki Phạm" />
            </div>
            <p id="username" data-text="@niyakipham">@niyakipham</p>
            <div id="clock">00:00:00</div>
        </div>

        <!-- /// TO-DO LIST SECTION /// -->
        <section id="todo-section" aria-labelledby="todo-heading">
            <h2 id="todo-heading" class="sci-fi-heading">TO DO LIST</h2>
            <form id="todo-form" aria-label="Thêm nhiệm vụ mới">
                <div class="todo-input-group">
                    <input type="text" id="todo-input" placeholder="Nhiệm vụ mới..." required
                        aria-label="Nội dung nhiệm vụ">
                    <input type="time" id="todo-time" aria-label="Thời gian nhắc nhở"
                        title="Chọn giờ nhắc nhở (trong ngày)">
                </div>
                <button type="submit" id="add-todo-btn" aria-label="Thêm nhiệm vụ">
                    <ion-icon name="add-circle-outline"></ion-icon> ADD
                </button>
            </form>
            <ul id="todo-list" aria-live="polite"><!-- Todo items appear here --></ul>
            <button id="request-permission-btn" style="display: none;" aria-label="Yêu cầu quyền hiển thị thông báo">
                <ion-icon name="notifications-outline"></ion-icon> Cho phép thông báo
            </button>
        </section>
        <!-- /// END TO-DO LIST /// -->

        <!-- /// AUDIO PLAYER /// -->
        <div id="audio-player">
            <div class="track-info">
                <span id="track-title" title="Đang tải nhạc...">Đang tải nhạc...</span>
                <div class="progress-container">
                    <div id="progress-bar"></div>
                </div>
            </div>
            <div class="controls">
                <div class="main-controls">
                    <button id="prev-btn" aria-label="Bài trước" disabled><ion-icon
                            name="play-skip-back-outline"></ion-icon></button>
                    <button id="play-pause-btn" aria-label="Phát nhạc" disabled><ion-icon
                            name="play-outline"></ion-icon></button>
                    <button id="next-btn" aria-label="Bài tiếp theo" disabled><ion-icon
                            name="play-skip-forward-outline"></ion-icon></button>
                </div>
            </div>
            <!-- Container ẩn cho YouTube Player -->
            <div id="youtube-player-container"></div>
        </div>
        <!-- /// END AUDIO PLAYER /// -->

        <!-- === ANIME SEARCH SECTION === -->
        <section id="anime-search-section" aria-labelledby="anime-search-heading">
            <h2 id="anime-search-heading" class="sci-fi-heading">KHÁM PHÁ ANIME</h2>
            <div id="search-wrapper">
                <input type="search" id="anime-search-input" placeholder="Đang tải data..."
                    aria-label="Nhập tên anime cần tìm" disabled>
                <button id="search-button" aria-label="Tìm kiếm" disabled><ion-icon
                        name="search-outline"></ion-icon></button>
            </div>
            <div id="anime-results-container" aria-live="polite">
                <p class="placeholder-text">Đang tải dữ liệu anime...</p>
            </div>
            <div id="anime-episode-list-container">
                <h3 id="episode-list-heading" class="sci-fi-heading" style="display: none;">Anime Title</h3>
                <ul id="anime-episode-list" aria-live="polite"></ul>
                <button id="back-to-search-btn" style="display: none;"><ion-icon name="arrow-back-outline"></ion-icon>
                    Quay lại</button>
            </div>
        </section>
        <!-- === END ANIME SEARCH SECTION === -->

        <!-- /// LINKS LIST /// -->
        <nav id="links" aria-label="Liên kết chính">
            <span id="main-content" class="visually-hidden">Nội dung chính</span>
            <ul>
                <li><a href="https://facebook.com/niyakipham" target="_blank" rel="noopener noreferrer">Facebook</a>
                </li>
                <li><a href="https://zalo.me/0901574726" target="_blank" rel="noopener noreferrer">Zalo</a></li>
                <li><a href="https://github.com/niyakipham" target="_blank" rel="noopener noreferrer">Github</a></li>
                <li><a href="https://discordapp.com/users/niyakipham.off" target="_blank"
                        rel="noopener noreferrer">Discord</a></li>
            </ul>
        </nav>
        <!-- /// END LINKS LIST /// -->

        <!-- /// SOCIAL LINKS /// -->
        <div id="social-links" aria-label="Liên kết mạng xã hội khác">
            <a href="https://github.com/niyakipham" target="_blank" rel="noopener noreferrer"
                aria-label="Niyaki Phạm trên Github" title="Github"><ion-icon name="logo-github"></ion-icon></a>
            <a href="https://instagram.com/niyakipham" target="_blank" rel="noopener noreferrer"
                aria-label="Niyaki Phạm trên Instagram" title="Instagram"><ion-icon
                    name="logo-instagram"></ion-icon></a>
            <a href="https://youtube.com/@Nishimahayashii" target="_blank" rel="noopener noreferrer"
                aria-label="Niyaki Phạm trên Youtube" title="YouTube"><ion-icon name="logo-youtube"></ion-icon></a>
            <a href="https://www.linkedin.com/in/niyakipham/" target="_blank" rel="noopener noreferrer"
                aria-label="Niyaki Phạm trên LinkedIn" title="LinkedIn"><ion-icon name="logo-linkedin"></ion-icon></a>
        </div>

        <!-- /// FOOTER /// -->
        <footer>
            Website được tạo với ❤️ bởi <a href="https://github.com/niyakipham" target="_blank"
                rel="noopener noreferrer">Niyaki Pham (Phạm Văn Hoàng)</a>
        </footer>

    </div> <!-- End #container -->

    <!-- === IFRAME PLAYER CONTAINER (Anime Viewer) === -->
    <div id="anime-player-container">
        <button id="close-player-btn" aria-label="Đóng trình phát"><ion-icon
                name="close-circle-outline"></ion-icon></button>
        <h4 id="player-anime-title">Anime Title - Episode Name</h4>
        <div class="iframe-wrapper">
            <iframe id="anime-iframe" src="" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen title="Anime Player"></iframe>
        </div>
    </div>
    <!-- === END IFRAME PLAYER CONTAINER === -->

    <script>
        //********* JAVASCRIPT - VERSION 13.1 (Media Session API Integration) *********//
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURATION ---
            const introStaggerDelay = 70;
            const glitchEffectOnLoad = true;
            const glitchDuration = 1500;
            const ANIME_DATA_URL = 'https://raw.githubusercontent.com/niyakipham/data/refs/heads/main/anisub/anidata.csv';

            // --- *** PLAYLIST DATA (MP3 Links & YouTube Video IDs) *** ---
            const playlist = [
                // MP3 example (You need to host this file yourself)
                // { type: 'url', url: '/path/to/your/music.mp3', title: 'Sample MP3 Track', artist: 'Your Name', album: 'Test Album' },
                { type: 'youtube', videoId: '5GUaMOpfmr8', title: 'Tada koe hitsoku' },
                { type: 'youtube', videoId: 'hE2bHwqqYcc', title: 'Niji' },
                { type: 'youtube', videoId: 'AZLfAzVy_PM', title: 'Best Friend' }, // Corrected typo
                { type: 'youtube', videoId: 'MW79zgnSF40', title: 'Like I Do' },
                { type: 'youtube', videoId: '12gmxhEFeBo', title: 'Payphone' },
                { type: 'youtube', videoId: 'QwiuihFPPok', title: 'Tonight' },
                { type: 'youtube', videoId: 'HsM9VucuCtw', title: 'Shadow Of The Sun' },
                { type: 'youtube', videoId: 'mv23MnaNvGM', title: 'Love is Gone' },
                { type: 'youtube', videoId: 'p7CuxzGWY40', title: 'Tom Frane - Dont Leave' },
                { type: 'youtube', videoId: 'JzFZVmsZYOA', title: 'Nhạc Lofi Chill Top Xu Hướng 2024 Triệu View ' },
            ];

            // --- GET DOM ELEMENTS ---
            const container = document.getElementById('container');
            const clockElement = document.getElementById('clock');
            const usernameElement = document.getElementById('username');
            const avatar = document.getElementById('avatar');
            const todoSection = document.getElementById('todo-section');
            const todoForm = document.getElementById('todo-form');
            const todoInput = document.getElementById('todo-input');
            const todoTimeInput = document.getElementById('todo-time');
            const todoListElement = document.getElementById('todo-list');
            const requestPermissionBtn = document.getElementById('request-permission-btn');
            const audioPlayer = document.getElementById('audio-player');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const prevBtn = document.getElementById('prev-btn');
            const nextBtn = document.getElementById('next-btn');
            const playIcon = playPauseBtn?.querySelector('ion-icon');
            const progressBar = document.getElementById('progress-bar');
            const progressContainer = audioPlayer?.querySelector('.progress-container');
            const trackTitleElement = document.getElementById('track-title');
            const mainLinks = document.querySelectorAll('#links a');
            const socialLinksContainer = document.getElementById('social-links');
            const footerElement = document.querySelector('footer');
            const animeSearchSection = document.getElementById('anime-search-section');
            const searchInput = document.getElementById('anime-search-input');
            const searchButton = document.getElementById('search-button');
            const resultsContainer = document.getElementById('anime-results-container');
            const episodeListContainer = document.getElementById('anime-episode-list-container');
            const episodeListHeading = document.getElementById('episode-list-heading');
            const episodeListUl = document.getElementById('anime-episode-list');
            const playerContainer = document.getElementById('anime-player-container');
            const playerIframe = document.getElementById('anime-iframe');
            const playerTitle = document.getElementById('player-anime-title');
            const closePlayerBtn = document.getElementById('close-player-btn');
            const backToSearchBtn = document.getElementById('back-to-search-btn');
            const youtubePlayerContainer = document.getElementById('youtube-player-container'); // YouTube player will attach here

            // --- STATE VARIABLES ---
            let audio = null;
            let currentTrackIndex = -1;
            let isPlaying = false;
            let userHasInteracted = false;
            let playAfterLoad = false;
            let tasks = [];
            let notificationPermission = 'Notification' in window ? Notification.permission : 'unsupported';
            let clockInterval = null;
            let allEpisodeRecords = [];
            let currentAnimeTitle = '';
            let youtubePlayer = null;
            let youtubeApiReady = false;
            let youtubePlayerReady = false;
            let youtubeProgressInterval = null; // Used for YT UI progress bar
            let youtubePositionInterval = null; // Used for YT Media Session position update
            let currentPlayerType = 'none'; // 'url', 'youtube', 'none'

            // ============================
            // === HELPER FUNCTIONS ===
            // ============================
            function generateId() { return Date.now().toString(36) + Math.random().toString(36).substring(2, 7); }
            function formatTimeForDisplay(date) { if (!date || !(date instanceof Date) || isNaN(date)) return null; try { const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; } catch (e) { console.error("Lỗi định dạng giờ:", e); return null; } }
            function setPrimaryColorRGB() { if (typeof window === 'undefined' || !document?.documentElement) return; try { const s = window.getComputedStyle(document.documentElement); let c = s.getPropertyValue('--color-primary').trim(); let r = 225, g = 29, b = 72; if (c.startsWith('#')) { const h = c.substring(1); if (h.length === 3) { r = parseInt(h[0] + h[0], 16); g = parseInt(h[1] + h[1], 16); b = parseInt(h[2] + h[2], 16); } else if (h.length === 6) { r = parseInt(h.substring(0, 2), 16); g = parseInt(h.substring(2, 4), 16); b = parseInt(h.substring(4, 6), 16); } } else if (c.startsWith('rgb')) { const p = c.match(/(\d+)/g); if (p && p.length >= 3) { r = parseInt(p[0], 10); g = parseInt(p[1], 10); b = parseInt(p[2], 10); } } if (isNaN(r) || isNaN(g) || isNaN(b)) { [r, g, b] = [225, 29, 72]; console.warn("Cannot parse primary color, using default."); } document.documentElement.style.setProperty('--color-primary-rgb', `${r}, ${g}, ${b}`); } catch (e) { console.error("Error setting primary RGB:", e); document.documentElement.style.setProperty('--color-primary-rgb', `225, 29, 72`); } }
            function splitCsvLine(line) { const result = []; let current = ''; let inQuotes = false; for (let i = 0; i < line.length; i++) { const char = line[i]; if (char === '"') { if (inQuotes && line[i + 1] === '"') { current += '"'; i++; } else { inQuotes = !inQuotes; } } else if (char === ',' && !inQuotes) { result.push(current); current = ''; } else { current += char; } } result.push(current); return result; }
            function parseCSV_NameEpisodeLink(csvText) { if (!csvText) return []; const lines = csvText.trim().split('\n'); if (lines.length <= 1) return []; const header = lines[0].split(',').map(h => h.trim().toLowerCase()); const data = []; const nameIndex = header.indexOf('name'); const episodeNameIndex = header.indexOf('episodes'); const linkIndex = header.indexOf('link'); if (nameIndex === -1 || episodeNameIndex === -1 || linkIndex === -1) { console.error("❌ Critical Error: CSV must contain 'name', 'episodes', 'link'. Header:", header.join(', ')); if (resultsContainer) resultsContainer.innerHTML = '<p class="placeholder-text error">Lỗi cấu trúc file dữ liệu.</p>'; return []; } for (let i = 1; i < lines.length; i++) { const line = lines[i].trim(); if (!line) continue; try { const parts = splitCsvLine(line); if (parts.length <= Math.max(nameIndex, episodeNameIndex, linkIndex)) { console.warn(`⚠️ Skipping line ${i + 1}: Not enough columns. "${line.substring(0, 50)}..."`); continue; } const animeName = parts[nameIndex]?.trim(); const episodeName = parts[episodeNameIndex]?.trim(); const link = parts[linkIndex]?.trim(); if (!animeName || !episodeName) { console.warn(`⚠️ Skipping line ${i + 1}: Missing name/episode. Name: '${animeName}', Ep: '${episodeName}'`); continue; } data.push({ animeName: animeName, episodeName: episodeName, link: link || '#' }); } catch (e) { console.error(`❌ Error CSV line ${i + 1}: "${line.substring(0, 100)}...". Error: ${e.message}`); } } console.log(`ℹ️ Parsed ${data.length} episode records.`); return data; }
            function formatTimeForDisplayYT(seconds) { if (isNaN(seconds) || seconds < 0) return '0:00'; const minutes = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60); return `${minutes}:${secs < 10 ? '0' : ''}${secs}`; }

            // ============================
            // === MEDIA SESSION API INTEGRATION ===
            // ============================
            function setupMediaSession() {
                if ('mediaSession' in navigator) {
                    console.log('🚀 Media Session API is supported');

                    // --- Helper functions for Media Session ---
                    const updateMetadata = () => {
                        if (currentTrackIndex < 0 || currentTrackIndex >= playlist.length) {
                            navigator.mediaSession.metadata = null; // Clear metadata if no track
                            return;
                        }

                        const track = playlist[currentTrackIndex];
                        const title = track.title || (track.type === 'youtube' ? `YT: ${track.videoId}` : `Track ${currentTrackIndex + 1}`);
                        const artist = track.artist || "Niyaki Pham"; // Use track artist if available, else default
                        const album = track.album || "Sci-Fi Playlist"; // Use track album if available, else default
                        const artworkUrl = document.querySelector('meta[property="og:image"]')?.content || avatar?.src || 'https://niyakipham.github.io/assets/kaguya.jpeg'; // Fallback image

                        console.log(`🎵 Updating Media Session: ${title} - ${artist}`);

                        try {
                            navigator.mediaSession.metadata = new MediaMetadata({
                                title: title,
                                artist: artist,
                                album: album,
                                artwork: [
                                    { src: artworkUrl, sizes: '96x96', type: 'image/jpeg' },
                                    { src: artworkUrl, sizes: '128x128', type: 'image/jpeg' },
                                    { src: artworkUrl, sizes: '192x192', type: 'image/jpeg' },
                                    { src: artworkUrl, sizes: '256x256', type: 'image/jpeg' },
                                    { src: artworkUrl, sizes: '384x384', type: 'image/jpeg' },
                                    { src: artworkUrl, sizes: '512x512', type: 'image/jpeg' },
                                ]
                            });
                        } catch (error) {
                            console.error("Error setting Media Session metadata:", error);
                        }

                        // Update initial playback state and position state when metadata changes
                        updatePlaybackState();
                        updatePositionState(); // Call immediately after setting metadata
                    };

                    const updatePlaybackState = () => {
                        if ('mediaSession' in navigator && navigator.mediaSession.metadata) {
                            console.log(`⏯️ Media Session State Update: ${isPlaying ? 'playing' : 'paused'}`);
                            navigator.mediaSession.playbackState = isPlaying ? 'playing' : 'paused';
                        }
                    };

                    // Lấy thời lượng hiện tại (Dùng bởi updatePositionState và seek)
                    function getDuration() {
                        if (currentPlayerType === 'youtube' && youtubePlayerReady && typeof youtubePlayer.getDuration === 'function') return youtubePlayer.getDuration();
                        if (currentPlayerType === 'url' && audio && !isNaN(audio.duration)) return audio.duration;
                        return 0;
                    }

                    // Lấy tốc độ phát hiện tại (Dùng bởi updatePositionState)
                    function getCurrentPlaybackRate() {
                        if (currentPlayerType === 'youtube' && youtubePlayerReady && typeof youtubePlayer.getPlaybackRate === 'function') return youtubePlayer.getPlaybackRate();
                        if (currentPlayerType === 'url' && audio) return audio.playbackRate;
                        return 1;
                    }

                    // Hàm cập nhật vị trí phát cho Media Session
                    const updatePositionState = () => {
                        // Chỉ cập nhật nếu API được hỗ trợ, có metadata và không phải live stream/lỗi
                        if ('mediaSession' in navigator && navigator.mediaSession.metadata && typeof navigator.mediaSession.setPositionState === 'function') {
                            try {
                                const duration = getDuration();
                                const position = getCurrentPlaybackTime();
                                // Kiểm tra duration và position hợp lệ
                                if (duration > 0 && !isNaN(duration) && position >= 0 && !isNaN(position)) {
                                    // console.log(`⏱️ Media Session Position Update: Pos=${position.toFixed(2)}, Dur=${duration.toFixed(2)}`); // Log for debugging if needed
                                    navigator.mediaSession.setPositionState({
                                        duration: duration,
                                        playbackRate: getCurrentPlaybackRate(),
                                        position: position
                                    });
                                } else {
                                    // Xóa position state nếu duration là 0 hoặc NaN (live stream hoặc chưa load xong)
                                    // console.log(`⏱️ Media Session Position: Resetting state (Duration: ${duration}, Position: ${position})`);
                                    navigator.mediaSession.setPositionState(null);
                                }
                            } catch (e) { console.warn("Error setting Media Session position state:", e); }
                        }
                    };

                    // Hàm tiện ích để seek tương đối (tiến/lùi)
                    function seekRelative(offsetSeconds) {
                        const currentTime = getCurrentPlaybackTime();
                        const duration = getDuration();
                        if (duration > 0 && !isNaN(currentTime)) {
                            const newTime = Math.max(0, Math.min(duration, currentTime + offsetSeconds));
                            seekAbsolute(newTime);
                        }
                    }

                    // Hàm tiện ích để seek tuyệt đối (đồng bộ cả player và media session)
                    function seekAbsolute(seekTime) {
                        const duration = getDuration();
                        if (isNaN(seekTime) || seekTime < 0 || (duration > 0 && seekTime > duration)) {
                            console.warn(`Seek denied: Invalid time ${seekTime}`);
                            return;
                        }
                        console.log(`Seeking to: ${seekTime.toFixed(2)}s`);
                        if (progressBar) progressBar.style.width = duration > 0 ? `${(seekTime / duration) * 100}%` : '0%';

                        if (currentPlayerType === 'youtube' && youtubePlayerReady && typeof youtubePlayer.seekTo === 'function') {
                            youtubePlayer.seekTo(seekTime, true);
                        } else if (currentPlayerType === 'url' && audio && audio.readyState >= 1) {
                            // Avoid seeking if not ready or invalid state
                            try { audio.currentTime = seekTime; } catch (e) { console.error("Audio seek error:", e); }
                        }
                        // Cập nhật lại trạng thái vị trí Media Session ngay lập tức sau khi seek
                        if ('mediaSession' in navigator && typeof navigator.mediaSession.setPositionState === 'function' && navigator.mediaSession.metadata && duration > 0) {
                            navigator.mediaSession.setPositionState({
                                duration: duration,
                                playbackRate: getCurrentPlaybackRate(),
                                position: seekTime
                            });
                        } else if ('mediaSession' in navigator && typeof navigator.mediaSession.setPositionState === 'function') {
                            navigator.mediaSession.setPositionState(null); // Reset if duration unknown
                        }
                    }

                    // --- Gắn các trình xử lý hành động ---
                    navigator.mediaSession.setActionHandler('play', () => {
                        console.log('▶️ Media Session: Play triggered');
                        if (!isPlaying) togglePlayPause(); // Chỉ gọi nếu đang paused
                    });
                    navigator.mediaSession.setActionHandler('pause', () => {
                        console.log('⏸️ Media Session: Pause triggered');
                        if (isPlaying) togglePlayPause(); // Chỉ gọi nếu đang playing
                    });
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        console.log('⏮️ Media Session: Previous track triggered');
                        if (prevBtn && !prevBtn.disabled) playPrevTrack();
                    });
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        console.log('⏭️ Media Session: Next track triggered');
                        if (nextBtn && !nextBtn.disabled) playNextTrack(false);
                    });
                    navigator.mediaSession.setActionHandler('seekbackward', (details) => {
                        console.log('⏪ Media Session: Seek backward triggered', details);
                        const seekOffset = details.seekOffset || 10; // Default 10s
                        seekRelative(-seekOffset);
                    });
                    navigator.mediaSession.setActionHandler('seekforward', (details) => {
                        console.log('⏩ Media Session: Seek forward triggered', details);
                        const seekOffset = details.seekOffset || 10; // Default 10s
                        seekRelative(seekOffset);
                    });
                    navigator.mediaSession.setActionHandler('seekto', (details) => {
                        // Seek to a specific time (e.g., from progress bar in notification)
                        console.log('⏱️ Media Session: Seek to triggered', details);
                        // `details.fastSeek` is true if the user is scrubbing
                        // `details.seekTime` is the target time in seconds
                        if (!details.fastSeek && details.seekTime != null && !isNaN(details.seekTime)) {
                            seekAbsolute(details.seekTime);
                        }
                    });
                    navigator.mediaSession.setActionHandler('stop', () => {
                        // Stop playback completely (if different from pause)
                        console.log('⏹️ Media Session: Stop triggered');
                        if (isPlaying) pauseAudio();
                        // Optionally: Reset track index, clear metadata etc.
                        // currentTrackIndex = -1;
                        // navigator.mediaSession.metadata = null;
                        // navigator.mediaSession.playbackState = 'none';
                        // if (trackTitleElement) trackTitleElement.textContent = "Sẵn sàng phát nhạc";
                        // updatePlayPauseButton(false);
                        // disableAllControls();
                    });

                    // === Lưu các hàm để có thể gọi từ bên ngoài ===
                    window.mediaSessionInterface = {
                        updateMetadata,
                        updatePlaybackState,
                        updatePositionState
                    };


                } else {
                    console.log('⚠️ Media Session API is not supported.');
                    window.mediaSessionInterface = null; // Indicate unavailability
                }
            }


            // ============================
            // === YOUTUBE API FUNCTIONS ===
            // ============================
            function loadYouTubeAPI() {
                console.log("▶️ Loading YouTube API...");
                var tag = document.createElement('script');
                tag.src = "https://www.youtube.com/iframe_api";
                var firstScriptTag = document.getElementsByTagName('script')[0];
                firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
            }

            window.onYouTubeIframeAPIReady = function () {
                console.log("✅ YouTube API Script Ready");
                youtubeApiReady = true;
                // Nếu đang có bài hát YT chờ load thì load ngay
                if (currentPlayerType === 'youtube' && currentTrackIndex >= 0 && !youtubePlayer) {
                    console.log("API Ready: Triggering YT load for pending track index", currentTrackIndex);
                    loadTrack(currentTrackIndex);
                }
            }

            function onPlayerReady(event) {
                console.log("✅ YT Player Instance Ready (onReady). State:", event.target.getPlayerState());
                youtubePlayerReady = true;
                enableMainControls();
                updatePrevNextButtonStates();
                setYouTubeVolume(audio?.volume ?? 0.8); // Sync volume

                // Cập nhật vị trí/duration ban đầu cho Media Session
                if (window.mediaSessionInterface) window.mediaSessionInterface.updatePositionState();

                if (playAfterLoad) {
                    console.log("onPlayerReady: playAfterLoad=true -> Playing YT video...");
                    playAudio(); // This will trigger state change to PLAYING
                } else {
                    // Dù không play ngay, cập nhật trạng thái MediaSession là paused
                    if (window.mediaSessionInterface) window.mediaSessionInterface.updatePlaybackState(); // Set to paused initially
                }
            }

            function onPlayerStateChange(event) {
                const state = event.data;
                const stateName = Object.keys(YT.PlayerState).find(key => YT.PlayerState[key] === state) || 'UNKNOWN';
                console.log(`YT State Change: ${stateName} (${state})`);

                // --- Quản lý Interval cập nhật vị trí cho Media Session ---
                if (youtubePositionInterval) {
                    clearInterval(youtubePositionInterval);
                    youtubePositionInterval = null;
                    // console.log("Cleared YT position interval.");
                }

                if (state === YT.PlayerState.PLAYING) {
                    if (!youtubePlayerReady) youtubePlayerReady = true; // Mark as ready if playing starts
                    if (!isPlaying) {
                        isPlaying = true;
                        updatePlayPauseButton(true);
                        container?.classList.add('is-playing');
                        if (window.mediaSessionInterface) window.mediaSessionInterface.updatePlaybackState(); // <-- THÊM: Cập nhật MS
                        if (!youtubeProgressInterval) startYouTubeProgressTracking(); // For UI bar
                        // Bắt đầu interval cập nhật vị trí MediaSession
                        if (window.mediaSessionInterface) {
                            window.mediaSessionInterface.updatePositionState(); // Cập nhật ngay
                            youtubePositionInterval = setInterval(window.mediaSessionInterface.updatePositionState, 1000);
                            // console.log("Started YT position interval.");
                        }
                    }
                } else if (state === YT.PlayerState.PAUSED) {
                    if (isPlaying) {
                        isPlaying = false;
                        updatePlayPauseButton(false);
                        container?.classList.remove('is-playing');
                        if (window.mediaSessionInterface) window.mediaSessionInterface.updatePlaybackState(); // <-- THÊM: Cập nhật MS
                        if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                    }
                    // Giữ nguyên Position State khi Pause, chỉ dừng cập nhật interval
                } else if (state === YT.PlayerState.ENDED) {
                    isPlaying = false; youtubePlayerReady = false;
                    updatePlayPauseButton(false); container?.classList.remove('is-playing');
                    if (window.mediaSessionInterface) {
                        window.mediaSessionInterface.updatePlaybackState(); // <-- THÊM: Cập nhật MS
                        navigator.mediaSession.setPositionState?.(null); // <-- THÊM: Reset vị trí
                    }
                    if (progressBar) progressBar.style.width = '100%'; // Or 0% depending on desired behavior
                    if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                    playNextTrack(true); // Auto-advance
                } else if (state === YT.PlayerState.BUFFERING) {
                    // Có thể xem buffering là trạng thái chuẩn bị phát => isPlaying = true ?
                    // Hoặc giữ nguyên isPlaying ? Tùy vào UX mong muốn.
                    // Hiện tại không thay đổi isPlaying khi buffering.
                } else if (state === YT.PlayerState.CUED || state === YT.PlayerState.UNSTARTED) {
                    // Các trạng thái này coi như paused
                    if (!youtubePlayerReady && state === YT.PlayerState.CUED) youtubePlayerReady = true; // Sẵn sàng để play
                    if (isPlaying) { // If it was playing before entering these states
                        isPlaying = false;
                        updatePlayPauseButton(false);
                        container?.classList.remove('is-playing');
                        if (window.mediaSessionInterface) window.mediaSessionInterface.updatePlaybackState(); // <-- THÊM
                    }
                    if (youtubeProgressInterval && !isPlaying) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                    // Cập nhật vị trí/duration ban đầu khi CUED
                    if (window.mediaSessionInterface && state === YT.PlayerState.CUED) {
                        // Đợi chút để player thực sự có dữ liệu duration/position
                        setTimeout(window.mediaSessionInterface.updatePositionState, 250);
                    } else if (window.mediaSessionInterface && state === YT.PlayerState.UNSTARTED) {
                        navigator.mediaSession.setPositionState?.(null); // Reset position if unstarted
                    }
                }

                // General re-enabling of controls if player is interactive
                if ([YT.PlayerState.PLAYING, YT.PlayerState.PAUSED, YT.PlayerState.CUED].includes(state)) {
                    if (!youtubePlayerReady) youtubePlayerReady = true;
                    enableMainControls(); updatePrevNextButtonStates();
                } else if (state === YT.PlayerState.UNSTARTED) {
                    // Có thể cần disable control nếu player không sẵn sàng?
                    // disableMainControls(); // ?
                }
            }

            function onPlayerError(event) {
                console.error("YT Player Error Code:", event.data);
                let errorMsg = `Lỗi YT Player (${event.data})`;
                if (event.data === 2) errorMsg = "ID Video không hợp lệ";
                else if (event.data === 5) errorMsg = "Lỗi trình phát HTML5";
                else if (event.data === 100) errorMsg = "Không tìm thấy video";
                else if (event.data === 101 || event.data === 150) errorMsg = "Video riêng tư hoặc bị chặn";
                if (trackTitleElement) { trackTitleElement.textContent = errorMsg; trackTitleElement.classList.remove('is-youtube'); }

                // --- Cleanup on Error ---
                disableAllControls();
                isPlaying = false; youtubePlayerReady = false; currentPlayerType = 'none';
                updatePlayPauseButton(false); container?.classList.remove('is-playing');
                if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                if (youtubePositionInterval) { clearInterval(youtubePositionInterval); youtubePositionInterval = null; } // <-- THÊM
                if (window.mediaSessionInterface) { // <-- THÊM: Reset MS
                    navigator.mediaSession.metadata = null;
                    navigator.mediaSession.playbackState = 'none';
                    navigator.mediaSession.setPositionState?.(null);
                }
            }

            // Interval cho thanh progress bar GIAO DIỆN
            function startYouTubeProgressTracking() {
                if (youtubeProgressInterval) clearInterval(youtubeProgressInterval);
                youtubeProgressInterval = setInterval(updateYouTubeProgressAndDuration, 1000);
            }

            // Cập nhật thanh progress bar GIAO DIỆN
            function updateYouTubeProgressAndDuration() {
                if (currentPlayerType === 'youtube' && youtubePlayer && youtubePlayerReady && typeof youtubePlayer.getCurrentTime === 'function' && typeof youtubePlayer.getDuration === 'function') {
                    const currentTime = youtubePlayer.getCurrentTime();
                    const duration = youtubePlayer.getDuration();
                    if (duration > 0 && !isNaN(currentTime) && !isNaN(duration)) {
                        if (progressBar) progressBar.style.width = `${(currentTime / duration) * 100}%`;
                    } else if (duration <= 0 && progressBar) {
                        progressBar.style.width = '0%'; // Indicate live stream or error
                    }
                } else if (currentPlayerType !== 'youtube' && youtubeProgressInterval) {
                    // Dừng nếu player không còn là YT
                    clearInterval(youtubeProgressInterval); youtubeProgressInterval = null;
                }
            }

            function setYouTubeVolume(volume) {
                if (youtubePlayer && youtubePlayerReady && typeof youtubePlayer.setVolume === 'function') {
                    youtubePlayer.setVolume(Math.round(volume * 100));
                }
            }

            // ============================
            // === CORE PLAYER LOGIC (Unified) ===
            // ============================

            function loadTrack(index) {
                if (!playlist || index < 0 || index >= playlist.length) {
                    console.error("Load track failed: Invalid index or empty playlist.");
                    if (trackTitleElement) trackTitleElement.textContent = playlist?.length ? "Lỗi Index" : "Playlist Trống";
                    trackTitleElement?.classList.remove('is-youtube');
                    disableAllControls();
                    currentPlayerType = 'none'; currentTrackIndex = -1;
                    // Reset Media Session khi không load được track
                    if (window.mediaSessionInterface) { // <-- THÊM
                        navigator.mediaSession.metadata = null;
                        navigator.mediaSession.playbackState = 'none';
                        navigator.mediaSession.setPositionState?.(null);
                    }
                    return;
                }
                console.log(`--- Loading Track ${index} ---`);
                // Stop previous playback & cleanup intervals
                if (audio && !audio.paused) audio.pause();
                if (youtubePlayer && youtubePlayerReady && typeof youtubePlayer.stopVideo === 'function') {
                    youtubePlayer.stopVideo(); // Stop first
                }
                if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                if (youtubePositionInterval) { clearInterval(youtubePositionInterval); youtubePositionInterval = null; } // <-- THÊM


                // Reset common state
                isPlaying = false; playAfterLoad = false; // playAfterLoad will be set later if needed
                youtubePlayerReady = (currentPlayerType === 'youtube' && youtubePlayer) ? false : youtubePlayerReady; // Reset ready state if reloading YT
                currentTrackIndex = index;
                updatePlayPauseButton(false);
                if (progressBar) progressBar.style.width = '0%';
                container?.classList.remove('is-playing');
                disableAllControls(); // Controls will be enabled on 'canplay' or 'onReady'

                const track = playlist[currentTrackIndex];
                const trackType = track.type || 'url';
                currentPlayerType = trackType; // Set early
                const displayTitle = track.title || (trackType === 'youtube' ? `YouTube: ${track.videoId}` : `Track ${index + 1}`);
                if (trackTitleElement) {
                    trackTitleElement.textContent = displayTitle; trackTitleElement.title = displayTitle;
                    trackTitleElement.classList.toggle('is-youtube', trackType === 'youtube');
                }

                // --> Cập nhật Media Session Metadata NGAY KHI CÓ THÔNG TIN <--
                if (window.mediaSessionInterface) window.mediaSessionInterface.updateMetadata();


                if (trackType === 'youtube') {
                    console.log(`Type: YouTube, Video ID: ${track.videoId}`);
                    if (!track.videoId) {
                        if (trackTitleElement) trackTitleElement.textContent = "Lỗi ID YouTube";
                        currentPlayerType = 'none';
                        if (window.mediaSessionInterface) navigator.mediaSession.metadata = null; // Clear MS
                        return;
                    }
                    // Clean up HTML5 audio if it was used
                    if (audio && audio.src) {
                        audio.removeAttribute('src');
                        audio.load(); // Reset
                    }

                    if (!youtubeApiReady) {
                        console.warn("Cannot load YouTube: API not ready yet.");
                        if (trackTitleElement) trackTitleElement.textContent = "Chờ API YouTube...";
                        currentPlayerType = 'none'; // Indicate failure for now
                        if (window.mediaSessionInterface) navigator.mediaSession.metadata = null;
                        return; // Will retry when API is ready
                    }

                    if (youtubePlayer && typeof youtubePlayer.loadVideoById === 'function') { // Reuse player
                        console.log("Reusing YT Player instance. Loading:", track.videoId);
                        // `loadVideoById` triggers state changes including CUED or playing
                        youtubePlayer.loadVideoById(track.videoId); // Autoplay is off, handled by `playAfterLoad` later
                    } else { // Create new player
                        console.log("Creating new YT Player instance for:", track.videoId);
                        if (document.getElementById('youtube-player-container')) { // Make sure container exists
                            youtubePlayer = new YT.Player('youtube-player-container', {
                                height: '1', width: '1', videoId: track.videoId,
                                playerVars: {
                                    'playsinline': 1,
                                    'autoplay': 0, // Explicitly 0, control via playAudio()
                                    'controls': 0, // Hide YouTube controls
                                    'disablekb': 1, // Disable keyboard shortcuts
                                    'fs': 0, // Disable fullscreen button
                                    'iv_load_policy': 3, // Don't show annotations
                                    'modestbranding': 1, // Less YouTube branding
                                    'rel': 0 // Don't show related videos at end
                                },
                                events: {
                                    'onReady': onPlayerReady,
                                    'onStateChange': onPlayerStateChange,
                                    'onError': onPlayerError
                                }
                            });
                        } else {
                            console.error("youtube-player-container not found!");
                            currentPlayerType = 'none';
                            if (window.mediaSessionInterface) navigator.mediaSession.metadata = null;
                        }
                    }
                } else { // url track (HTML5 Audio)
                    console.log(`Type: URL, Source: ${track.url}`);
                    if (!track.url) {
                        if (trackTitleElement) trackTitleElement.textContent = "Lỗi URL Track";
                        currentPlayerType = 'none';
                        if (window.mediaSessionInterface) navigator.mediaSession.metadata = null; // Clear MS
                        return;
                    }
                    if (typeof Audio === 'undefined') {
                        if (trackTitleElement) trackTitleElement.textContent = "Lỗi Audio HTML5";
                        currentPlayerType = 'none';
                        if (window.mediaSessionInterface) navigator.mediaSession.metadata = null; // Clear MS
                        return;
                    }

                    // Clean up YouTube player if it was used
                    if (youtubePlayer) {
                        try { youtubePlayer.stopVideo(); youtubePlayer.destroy(); } catch (e) { console.warn("Minor YT cleanup error:", e); }
                        youtubePlayer = null;
                        youtubePlayerReady = false;
                        if (youtubePositionInterval) { clearInterval(youtubePositionInterval); youtubePositionInterval = null; }
                        if (youtubeProgressInterval) { clearInterval(youtubeProgressInterval); youtubeProgressInterval = null; }
                    }

                    if (!audio) { // Create Audio element if needed
                        try {
                            audio = new Audio();
                            audio.preload = 'metadata'; // Load metadata first
                            addAudioListeners(); // Add listeners ONLY once
                        }
                        catch (e) {
                            console.error("Cannot create Audio obj:", e);
                            if (trackTitleElement) trackTitleElement.textContent = "Lỗi Audio";
                            currentPlayerType = 'none';
                            if (window.mediaSessionInterface) navigator.mediaSession.metadata = null; // Clear MS
                            return;
                        }
                    }
                    try {
                        console.log("Setting audio src & load...");
                        // Only change src if different to avoid unnecessary reloads
                        if (audio.src !== track.url) {
                            audio.src = track.url;
                        }
                        audio.load(); // 'canplay' event handles enabling controls & potential autoplay
                    } catch (e) {
                        console.error("Audio src/load error:", e);
                        if (trackTitleElement) trackTitleElement.textContent = "Lỗi Load Audio";
                        disableAllControls();
                        currentPlayerType = 'none';
                        if (window.mediaSessionInterface) navigator.mediaSession.metadata = null; // Clear MS
                    }
                }

            }

            function addAudioListeners() { // Attached only once to the Audio object
                if (!audio) return;
                console.log("Attaching listeners to Audio element.");

                audio.addEventListener('timeupdate', () => {
                    // Update UI progress bar
                    if (currentPlayerType === 'url' && audio.duration && !isNaN(audio.duration) && progressBar && isPlaying) {
                        progressBar.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
                    }
                    // Update Media Session Position if playing
                    if (currentPlayerType === 'url' && isPlaying && window.mediaSessionInterface) {
                        window.mediaSessionInterface.updatePositionState(); // <-- THÊM: Cập nhật MS
                    }
                });

                audio.addEventListener('ended', () => {
                    if (currentPlayerType === 'url') {
                        console.log("Audio ended");
                        isPlaying = false;
                        updatePlayPauseButton(false);
                        container?.classList.remove('is-playing');
                        // Reset position before next track (or for UI if loop disabled)
                        if (progressBar) progressBar.style.width = '0%'; // Reset UI progress
                        if (window.mediaSessionInterface) { // <-- THÊM: Cập nhật MS
                            window.mediaSessionInterface.updatePlaybackState();
                            navigator.mediaSession.setPositionState?.(null);
                        }
                        playNextTrack(true); // Auto-advance
                    }
                });

                audio.addEventListener('error', (e) => {
                    if (currentPlayerType === 'url') { // Only handle if HTML5 audio is the current player
                        let errorMsg = "Audio Err"; let detailedCode = '';
                        if (audio.error) {
                            detailedCode = ` (Code: ${audio.error.code})`;
                            switch (audio.error.code) {
                                case MediaError.MEDIA_ERR_ABORTED: errorMsg = 'Tải bị hủy'; break;
                                case MediaError.MEDIA_ERR_NETWORK: errorMsg = 'Lỗi mạng'; break;
                                case MediaError.MEDIA_ERR_DECODE: errorMsg = 'Lỗi giải mã'; break;
                                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: errorMsg = 'Định dạng không hỗ trợ'; break;
                                default: errorMsg = `Lỗi không xác định${detailedCode}`;
                            }
                        }
                        console.error(`HTML5 Audio Error: ${errorMsg}`, e);
                        if (trackTitleElement) trackTitleElement.textContent = errorMsg;
                        disableAllControls(); isPlaying = false; playAfterLoad = false; currentPlayerType = 'none';
                        updatePlayPauseButton(false); container?.classList.remove('is-playing');
                        // Reset Media Session on error
                        if (window.mediaSessionInterface) { // <-- THÊM
                            navigator.mediaSession.metadata = null;
                            navigator.mediaSession.playbackState = 'none';
                            navigator.mediaSession.setPositionState?.(null);
                        }
                    }
                });

                audio.addEventListener('canplay', () => {
                    if (currentPlayerType === 'url') { // Only handle if HTML5 audio is the current player
                        console.log("Audio CanPlay");
                        if (!audio.error) {
                            enableMainControls(); updatePrevNextButtonStates();
                            // Update duration for Media Session as soon as it's available
                            if (window.mediaSessionInterface) window.mediaSessionInterface.updatePositionState(); // <-- THÊM
                            if (playAfterLoad) {
                                // playAfterLoad = false; // playAudio will reset it
                                playAudio(); // Now it should be ready to play
                            } else {
                                // Even if not playing, update state to paused
                                if (window.mediaSessionInterface) window.mediaSessionInterface.updatePlaybackState(); // <-- THÊM
                            }
                        } else {
                            console.error("Audio CanPlay received but error state exists:", audio.error);
                        }
                    }
                });

                audio.addEventListener('loadstart', () => {
                    if (currentPlayerType === 'url') {
                        console.log("Audio Load Start...");
                        // Possibly disable controls during load?
                        disableMainControls(); // Optional: Disable until 'canplay'
                        if (progressBar) progressBar.style.width = '0%';
                    }
                });

                audio.addEventListener('pause', () => {
                    // This event fires when pause() is called OR when playback finishes/errors
                    if (currentPlayerType === 'url' && isPlaying) { // Only act if WE know it was playing
                        console.log("Audio Paused");
                        isPlaying = false;
                        updatePlayPauseButton(false);
                        playAfterLoad = false; // Important: Don't auto-resume if paused manually
                        container?.classList.remove('is-playing');
                        if (window.mediaSessionInterface) window.mediaSessionInterface.updatePlaybackState(); // <-- THÊM
                    }
                });

                audio.addEventListener('play', () => {
                    // This event fires when play() is called AND playback actually begins
                    if (currentPlayerType === 'url' && !isPlaying) { // Only act if WE know it wasn't playing
                        console.log("Audio Playing");
                        isPlaying = true;
                        updatePlayPauseButton(true);
                        container?.classList.add('is-playing');
                        if (window.mediaSessionInterface) { // <-- THÊM
                            window.mediaSessionInterface.updatePlaybackState();
                            // Cập nhật vị trí ban đầu ngay khi bắt đầu play
                            window.mediaSessionInterface.updatePositionState();
                        }
                    }
                });

                audio.addEventListener('seeking', () => {
                    if (currentPlayerType === 'url') console.log("Audio Seeking...");
                    // Maybe show a loading indicator?
                });
                audio.addEventListener('seeked', () => {
                    if (currentPlayerType === 'url') {
                        console.log("Audio Seeked.");
                        // Ensure UI progress bar matches after seek
                        if (progressBar && audio.duration > 0 && !isNaN(audio.currentTime)) {
                            progressBar.style.width = `${(audio.currentTime / audio.duration) * 100}%`;
                        }
                        // Ensure Media Session position is updated after seek
                        if (window.mediaSessionInterface) window.mediaSessionInterface.updatePositionState(); // <-- THÊM
                    }
                });
                // Event 'durationchange' can also be useful to update duration in Media Session
                audio.addEventListener('durationchange', () => {
                    if (currentPlayerType === 'url' && window.mediaSessionInterface) {
                        console.log("Audio duration changed:", audio.duration);
                        window.mediaSessionInterface.updatePositionState(); // Update MS including the new duration
                    }
                });
                // Event 'ratechange' if you allow changing playback speed
                audio.addEventListener('ratechange', () => {
                    if (currentPlayerType === 'url' && window.mediaSessionInterface) {
                        console.log("Audio playbackRate changed:", audio.playbackRate);
                        window.mediaSessionInterface.updatePositionState(); // Update MS including the new rate
                    }
                });


            } // End addAudioListeners

            function togglePlayPause() {
                if (!userHasInteracted) {
                    console.warn("Interaction needed for playback. Attempting to activate.");
                    userHasInteracted = true; // Assume interaction after first click
                    // Workaround for potential audio context suspension (mainly for Web Audio API, less critical for HTML5 Audio/YT)
                    // try {
                    //     if (window.AudioContext && !window.globalAudioContext) window.globalAudioContext = new AudioContext();
                    //     if (window.globalAudioContext && window.globalAudioContext.state === 'suspended') {
                    //         window.globalAudioContext.resume().then(() => console.log("AudioContext resumed."));
                    //     }
                    // } catch(e) { console.error("AudioContext resume error:", e); }
                }

                if (playPauseBtn?.disabled && !(currentTrackIndex < 0 && playlist.length > 0)) {
                    console.log("Play/Pause button is disabled.");
                    return; // Do nothing if disabled unless it's the initial play
                }

                if (isPlaying) {
                    pauseAudio();
                } else {
                    // If no track is loaded yet, load the first one and set to play after load
                    if (currentTrackIndex < 0 && playlist.length > 0) {
                        console.log("No track loaded, loading first and setting playAfterLoad.");
                        playAfterLoad = true; // Signal to play after load is complete
                        loadTrack(0);
                    } else {
                        // If a track IS loaded (or loading), just call playAudio
                        playAfterLoad = true; // Signal intention to play
                        playAudio();
                    }
                }
            }

            function playAudio() {
                if (!userHasInteracted) { // Double check interaction on play command
                    console.warn("Play called without prior interaction. Needs click first.");
                    // Possibly show a message to the user?
                    return; // Don't proceed without interaction
                }

                playAfterLoad = false; // Reset flag once play is attempted

                if (currentPlayerType === 'youtube') {
                    if (youtubePlayer && youtubePlayerReady && typeof youtubePlayer.playVideo === 'function') {
                        console.log("CMD: YT playVideo()");
                        youtubePlayer.playVideo(); // Triggers state change event
                    } else if (youtubePlayer && !youtubePlayerReady) {
                        console.warn("CMD: YT Play called but player not ready. Setting playAfterLoad.");
                        playAfterLoad = true; // Try again when onPlayerReady fires
                    } else if (!youtubePlayer && currentTrackIndex >= 0) {
                        console.warn("CMD: YT Play called but no player. Triggering load & setting playAfterLoad.");
                        playAfterLoad = true; // Set flag to play after load completes
                        loadTrack(currentTrackIndex); // Attempt to load/create player
                    } else {
                        console.error("Cannot Play YT: Invalid state (No Player/Ready/Track?).");
                        updatePlayPauseButton(false);
                    }
                } else if (currentPlayerType === 'url') {
                    if (!audio || !audio.src) {
                        console.error("Cannot Play Audio: No audio object or src.");
                        if (currentTrackIndex >= 0) {
                            playAfterLoad = true; loadTrack(currentTrackIndex); // Try loading and playing
                        } else updatePlayPauseButton(false); return;
                    }
                    if (audio.readyState < audio.HAVE_FUTURE_DATA) { // Need more data than just metadata to play smoothly
                        console.warn("Audio not ready enough to play:", audio.readyState, ". Setting playAfterLoad and calling load().");
                        playAfterLoad = true; // Try again when 'canplay' fires
                        audio.load(); // Trigger loading more data
                        return;
                    }
                    console.log("CMD: Audio play()");
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise
                            .then(_ => {
                                // Playback started successfully (handled by 'play' event listener now)
                            })
                            .catch(error => {
                                console.error(`Audio Play Failed: ${error.name}`, error);
                                isPlaying = false; playAfterLoad = false; updatePlayPauseButton(false); container?.classList.remove('is-playing');
                                // Reset Media Session state on failure
                                if (window.mediaSessionInterface) window.mediaSessionInterface.updatePlaybackState(); // <-- THÊM

                                if (error.name === 'NotAllowedError') {
                                    if (trackTitleElement && !trackTitleElement.textContent.includes("Click")) trackTitleElement.textContent += " (Click Play)";
                                    userHasInteracted = false; // Require interaction again
                                } else if (error.name === 'NotSupportedError') {
                                    if (trackTitleElement) trackTitleElement.textContent = "Format Error";
                                    disableAllControls(); currentPlayerType = 'none';
                                    if (window.mediaSessionInterface) navigator.mediaSession.metadata = null; // Clear MS
                                } else {
                                    if (trackTitleElement) trackTitleElement.textContent = `Play Error: ${error.name}`;
                                    disableMainControls();
                                }
                                updatePrevNextButtonStates();
                            });
                    } else {
                        // If playPromise is undefined, assume playback started (older browsers?)
                        // 'play' event should still handle state updates
                    }
                } else {
                    console.warn("Cannot Play: No valid player type set."); updatePlayPauseButton(false);
                    if (currentTrackIndex < 0 && playlist.length > 0) {
                        console.log("No player type, attempting to load first track for playing.");
                        playAfterLoad = true; loadTrack(0);
                    }
                }
            }

            function pauseAudio() {
                playAfterLoad = false; // Cancel any pending auto-play

                if (currentPlayerType === 'youtube') {
                    if (youtubePlayer && youtubePlayerReady && typeof youtubePlayer.pauseVideo === 'function') {
                        // Check current state BEFORE pausing, only pause if playing
                        const currentState = youtubePlayer.getPlayerState();
                        if (currentState === YT.PlayerState.PLAYING || currentState === YT.PlayerState.BUFFERING) {
                            console.log("CMD: YT pauseVideo()");
                            youtubePlayer.pauseVideo(); // Triggers state change event
                        } else { console.log("CMD: YT pauseVideo skipped, not playing/buffering. State:", currentState); }
                    } else console.warn("Cannot Pause YT: Not ready or no player.");
                } else if (currentPlayerType === 'url') {
                    if (audio && !audio.paused) { // Check if it's actually playing
                        console.log("CMD: Audio pause()");
                        audio.pause(); // Triggers 'pause' event
                    } else console.warn("Cannot Pause Audio: Not playing or no player.");
                } else console.warn("Cannot Pause: No valid player type.");
            }

            function playNextTrack(triggeredByEnd = false) {
                console.log("CMD: Play Next");
                if (!playlist || playlist.length === 0) return;
                if (playlist.length === 1 && !triggeredByEnd) {
                    console.log("Only one track, seeking to start."); seekToStart(); return;
                }
                // Keep playing if it was already playing OR if the track ended automatically
                const shouldContinuePlay = isPlaying || triggeredByEnd;
                playAfterLoad = shouldContinuePlay; // Set flag for the NEXT track load
                const nextIndex = (currentTrackIndex + 1) % playlist.length;
                loadTrack(nextIndex);
            }

            function playPrevTrack() {
                console.log("CMD: Play Previous");
                if (!playlist || playlist.length === 0) return;
                // Keep playing if it was already playing
                const shouldContinuePlay = isPlaying;
                // If playing and current time > 3 seconds, restart current track instead
                if (shouldContinuePlay && getCurrentPlaybackTime() > 3) {
                    console.log("Restarting current track."); seekToStart(); return;
                }
                if (playlist.length === 1) { seekToStart(); return; } // Restart if only one track

                playAfterLoad = shouldContinuePlay; // Set flag for the PREV track load
                const prevIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
                loadTrack(prevIndex);
            }

            function getCurrentPlaybackTime() {
                if (currentPlayerType === 'youtube' && youtubePlayerReady && typeof youtubePlayer.getCurrentTime === 'function') {
                    try { return youtubePlayer.getCurrentTime(); } catch (e) { return 0; }
                } else if (currentPlayerType === 'url' && audio && !isNaN(audio.currentTime)) {
                    return audio.currentTime;
                }
                return 0;
            }

            // Seek to start wrapper
            function seekToStart() {
                seekAbsolute(0);
                if (!isPlaying && progressBar) { // Update UI progress bar if paused after seeking
                    requestAnimationFrame(() => { if (progressBar) progressBar.style.width = '0%'; });
                }
            }

            // --- UI Controls Update ---
            function enableMainControls() { if (playPauseBtn) playPauseBtn.disabled = false; if (progressContainer) progressContainer.style.cursor = 'pointer'; updatePrevNextButtonStates(); }
            function disableMainControls() { if (playPauseBtn) playPauseBtn.disabled = true; if (progressContainer) progressContainer.style.cursor = 'default'; }
            function disableAllControls() { disableMainControls(); if (prevBtn) prevBtn.disabled = true; if (nextBtn) nextBtn.disabled = true; }
            function updatePrevNextButtonStates() { const canGo = playlist && playlist.length > 0; if (prevBtn) prevBtn.disabled = !canGo /*|| playPauseBtn?.disabled*/; if (nextBtn) nextBtn.disabled = !canGo /*|| playPauseBtn?.disabled*/; } // Allow prev/next even if main play paused? Or sync with playPauseBtn disabled state? Keep it simple: depend only on playlist size for now.
            function updatePlayPauseButton(playing) { if (playIcon) playIcon.setAttribute('name', playing ? 'pause-outline' : 'play-outline'); if (playPauseBtn) playPauseBtn.setAttribute('aria-label', playing ? 'Tạm dừng' : 'Phát'); }

            // --- Progress Bar Click/Seek Handler ---
            if (progressContainer) {
                progressContainer.addEventListener('click', (e) => {
                    if (!audio && !youtubePlayerReady) { // Don't seek if no player is ready
                        console.log("Seek ignored: No active player.");
                        return;
                    }
                    let duration = getDuration(); // Use the unified function
                    if (!(duration > 0)) { // Check if duration is valid
                        console.log("Seek ignored: Duration unknown or invalid:", duration);
                        return;
                    }
                    try {
                        const rect = progressContainer.getBoundingClientRect();
                        // Basic check to see if click is roughly within the bar's horizontal bounds
                        if (e.clientX < rect.left || e.clientX > rect.right) return;

                        // Calculate click position as a fraction (0 to 1)
                        const clickFraction = Math.max(0, Math.min(1, (e.clientX - rect.left) / progressContainer.offsetWidth));
                        const newTime = clickFraction * duration;

                        seekAbsolute(newTime); // Use the unified seek function <-- SỬA ĐỔI

                    } catch (err) { console.error("Seek click handling error:", err); }
                });
            }

            // ============================
            // === CLOCK / TODO / ANIME (Logic không đổi, giữ nguyên) ===
            // ============================
            // (Copy nguyên phần logic của Clock, Todo, Anime Search từ code gốc vào đây)
            // ... (Đã rút gọn để giảm độ dài, copy nguyên văn từ code bạn gửi)
            function updateClock() { if (!clockElement) return; try { const n = new Date(), h = String(n.getHours()).padStart(2, '0'), m = String(n.getMinutes()).padStart(2, '0'), s = String(n.getSeconds()).padStart(2, '0'); clockElement.textContent = `${h}:${m}:${s}`; } catch (e) { console.error("Clock err:", e); if (clockInterval) clearInterval(clockInterval); } }
            function scheduleNotification(t) { if (!t.notifyTime || t.completed || !(t.notifyTime instanceof Date) || isNaN(t.notifyTime)) return; const n = Date.now(), s = t.notifyTime.getTime(), d = s - n; if (t.timeoutId) { clearTimeout(t.timeoutId); t.timeoutId = null; } if (d > 0 && notificationPermission === 'granted') { t.timeoutId = setTimeout(() => { showNotification(t); const c = tasks.find(x => x.id === t.id); if (c) { c.timeoutId = null; saveTasks(); renderTasks(); } }, d); } else t.timeoutId = null; }
            function showNotification(t) { if (notificationPermission !== 'granted') return; try { const n = new Notification('📅 Việc cần làm!', { body: t.text, icon: 'https://niyakipham.github.io/assets/kaguya.jpeg', tag: t.id, renotify: true }); n.onclick = () => { window.focus(); const l = todoListElement?.querySelector(`li[data-id="${t.id}"]`); if (l) { l.scrollIntoView({ behavior: 'smooth', block: 'center' }); l.style.backgroundColor = 'rgba(var(--color-primary-rgb),0.2)'; setTimeout(() => { l.style.backgroundColor = ''; }, 1500); } }; n.onerror = e => console.error('Notif err:', e); } catch (e) { console.error('Show notif err:', e); } }
            function renderTask(t) { const l = document.createElement('li'); l.dataset.id = t.id; l.className = t.completed ? 'completed' : '';/* l.style.opacity='0'; l.style.transform='translateX(-10px)'; // Managed by intro anim */ const c = document.createElement('div'); c.className = 'todo-content'; const s = document.createElement('span'); s.className = 'todo-text'; s.textContent = t.text; c.appendChild(s); const d = formatTimeForDisplay(t.notifyTime); if (d) { const i = document.createElement('div'); i.className = 'todo-time-info'; const n = document.createElement('ion-icon'); n.setAttribute('name', 'alarm-outline'); n.setAttribute('aria-hidden', 'true'); i.appendChild(n); const p = document.createElement('span'); const o = new Date(), a = new Date(o); a.setDate(o.getDate() + 1); let f = t.notifyTime?.toDateString() === o.toDateString() ? 'H.nay ' : (t.notifyTime?.toDateString() === a.toDateString() ? 'N.mai ' : ''); p.textContent = f + d; p.setAttribute('aria-label', `Nhắc lúc: ${f}${d}`); i.appendChild(p); if (t.notifyTime && t.notifyTime.getTime() < Date.now() && t.timeoutId === null && !t.completed) { const e = document.createElement('ion-icon'); e.setAttribute('name', 'checkmark-done-outline'); e.setAttribute('aria-hidden', 'true'); e.title = 'Đã qua giờ'; i.appendChild(e); } c.appendChild(i); } l.appendChild(c); const o = document.createElement('div'); o.className = 'todo-actions'; const a = document.createElement('button'); a.className = 'complete-btn'; const f = t.completed ? 'Chưa xong' : 'Hoàn thành'; a.setAttribute('aria-label', f); a.title = f; const e = document.createElement('ion-icon'); e.setAttribute('name', t.completed ? 'refresh-outline' : 'checkmark-circle-outline'); e.setAttribute('aria-hidden', 'true'); a.appendChild(e); a.addEventListener('click', () => toggleCompleteTask(t.id)); o.appendChild(a); const n = document.createElement('button'); n.className = 'delete-btn'; n.setAttribute('aria-label', 'Xóa'); n.title = 'Xóa'; const m = document.createElement('ion-icon'); m.setAttribute('name', 'trash-outline'); m.setAttribute('aria-hidden', 'true'); n.appendChild(m); n.addEventListener('click', () => deleteTask(t.id)); o.appendChild(n); l.appendChild(o);/* requestAnimationFrame(()=>{l.style.opacity='1';l.style.transform='translateX(0)';}); */ return l; }
            function renderTasks() { if (!todoListElement) return; tasks.forEach(t => { if (t.timeoutId) clearTimeout(t.timeoutId); t.timeoutId = null; }); const f = document.createDocumentFragment(); if (!tasks.length) { const e = document.createElement('li'); e.textContent = 'Chưa có việc nào...'; e.style.cssText = 'justify-content:center;opacity:0.6;border-left:none;padding:var(--space-sm)'; f.appendChild(e); } else { tasks.forEach(t => f.appendChild(renderTask(t))); } todoListElement.innerHTML = ''; todoListElement.appendChild(f); tasks.forEach(t => { if (!t.completed && t.notifyTime && t.notifyTime.getTime() > Date.now() && !t.timeoutId) scheduleNotification(t); }); checkNotificationPermission(tasks.some(t => t.notifyTime && !t.completed)); /* Animation handled by intro timeline finish event */ }
            function saveTasks() { if (!window.localStorage) return; try { const s = tasks.map(t => ({ ...t, notifyTime: t.notifyTime?.toISOString() || null, timeoutId: null })); localStorage.setItem('niyakiTasks_v2', JSON.stringify(s)); } catch (e) { console.error("Save task err:", e); if (e.name === 'QuotaExceededError') alert('LocalStorage full!'); } }
            function loadTasks() { if (!window.localStorage) { tasks = []; renderTasks(); return; } const s = localStorage.getItem('niyakiTasks_v2'); if (s) { try { tasks = JSON.parse(s).map(t => ({ ...t, notifyTime: t.notifyTime ? new Date(t.notifyTime) : null, timeoutId: null })).filter(t => t.id && t.text); } catch (e) { console.error("Load task err:", e); localStorage.removeItem('niyakiTasks_v2'); tasks = []; } } else tasks = []; renderTasks(); }
            function addTask(e) { e.preventDefault(); const t = todoInput.value.trim(); const s = todoTimeInput.value; if (!t) return alert('Nhập nhiệm vụ!'), todoInput.focus(); let n = null; if (s) { const [h, m] = s.split(':').map(Number); if (!isNaN(h) && !isNaN(m)) { n = new Date(); n.setHours(h, m, 0, 0); if (n <= Date.now()) n.setDate(n.getDate() + 1); } else return alert('Giờ lỗi!'), todoTimeInput.focus(); } const N = { id: generateId(), text: t, notifyTime: n, completed: false, timeoutId: null }; tasks.unshift(N); saveTasks(); renderTasks(); /* New task added dynamically needs animation if desired */ const newTaskEl = todoListElement.querySelector(`li[data-id='${N.id}']`); if (newTaskEl && typeof anime !== 'undefined') { anime({ targets: newTaskEl, opacity: [0, 1], translateX: [-10, 0], duration: 300, easing: 'easeOutQuad' }); } todoInput.value = ''; todoTimeInput.value = ''; todoInput.focus(); }
            function deleteTask(i) { const d = tasks.findIndex(t => t.id === i); if (d > -1) { const task = tasks[d]; if (task.timeoutId) clearTimeout(task.timeoutId); const el = todoListElement?.querySelector(`li[data-id="${i}"]`); if (el) { /* Animate before removal */ if (typeof anime !== 'undefined') { anime({ targets: el, opacity: 0, translateX: 20, duration: 250, easing: 'easeInQuad', complete: () => { el.remove(); tasks.splice(d, 1); saveTasks(); if (!tasks.length) renderTasks(); } }); } else { el.remove(); tasks.splice(d, 1); saveTasks(); renderTasks(); } } else { tasks.splice(d, 1); saveTasks(); renderTasks(); } } }
            function toggleCompleteTask(i) { const d = tasks.findIndex(t => t.id === i); if (d > -1) { const t = tasks[d]; t.completed = !t.completed; if (t.completed && t.timeoutId) { clearTimeout(t.timeoutId); t.timeoutId = null; } else if (!t.completed && t.notifyTime && t.notifyTime > Date.now() && !t.timeoutId) scheduleNotification(t); saveTasks(); renderTasks(); const el = todoListElement?.querySelector(`li[data-id="${i}"]`); if (el) el.classList.toggle('completed', t.completed); /* Immediate class toggle is fine */ } }
            function checkNotificationPermission(s = false) { if (notificationPermission === 'unsupported' || !('Notification' in window)) { if (requestPermissionBtn) requestPermissionBtn.style.display = 'none'; return; } notificationPermission = Notification.permission; if (requestPermissionBtn) { if (notificationPermission === 'granted') { requestPermissionBtn.style.display = 'none'; tasks.forEach(t => { if (!t.completed && t.notifyTime && t.notifyTime > Date.now() && !t.timeoutId) scheduleNotification(t); }); } else if (notificationPermission === 'denied') requestPermissionBtn.style.display = 'none'; else requestPermissionBtn.style.display = s ? 'inline-flex' : 'none'; } }
            function handleRequestPermission() { if (notificationPermission === 'unsupported' || !('Notification' in window) || Notification.permission !== 'default') { checkNotificationPermission(false); return; } Notification.requestPermission().then(p => { notificationPermission = p; checkNotificationPermission(false); if (p === 'granted') new Notification('Đã cấp quyền!', { body: 'Sẽ có thông báo.', icon: 'https://niyakipham.github.io/assets/kaguya.jpeg' }), renderTasks(); else alert('Không cấp quyền.'); }).catch(e => console.error("Perm req err:", e)); }
            async function loadAnimeData() { console.log("⏳ Loading anime data..."); if (resultsContainer) resultsContainer.innerHTML = '<p class="placeholder-text">Đang tải dữ liệu anime...</p>'; if (searchInput) { searchInput.placeholder = "Đang tải..."; searchInput.disabled = true; } if (searchButton) searchButton.disabled = true; try { const r = await fetch(ANIME_DATA_URL); if (!r.ok) throw new Error(`HTTP ${r.status}`); const csv = await r.text(); allEpisodeRecords = parseCSV_NameEpisodeLink(csv); if (allEpisodeRecords.length > 0) { console.log("✅ Anime data loaded."); if (resultsContainer) resultsContainer.innerHTML = '<p class="placeholder-text">Nhập tên anime...</p>'; if (searchInput) { searchInput.placeholder = "Tìm kiếm anime..."; searchInput.disabled = false; } if (searchButton) searchButton.disabled = false; } else { console.warn("⚠️ No valid records parsed."); if (resultsContainer) resultsContainer.innerHTML = '<p class="placeholder-text error">Không có dữ liệu.</p>'; if (searchInput) searchInput.placeholder = "Lỗi data"; } } catch (e) { console.error("❌ Load/Parse anime error:", e); if (resultsContainer) resultsContainer.innerHTML = `<p class="placeholder-text error">Lỗi tải dữ liệu.</p>`; if (searchInput) { searchInput.placeholder = "Lỗi tải"; searchInput.disabled = true; } if (searchButton) searchButton.disabled = true; } }
            function renderSearchResults(uniqueNames) { if (!resultsContainer) return; resultsContainer.innerHTML = ''; if (!uniqueNames.length) { resultsContainer.innerHTML = searchInput?.value.trim() ? '<p class="placeholder-text">Không tìm thấy.</p>' : '<p class="placeholder-text">Nhập tên anime...</p>'; return; } const f = document.createDocumentFragment(); uniqueNames.forEach(n => { const i = document.createElement('div'); i.classList.add('search-result-item'); i.textContent = n; i.title = n; i.dataset.animeName = n; i.setAttribute('role', 'button'); i.tabIndex = 0; i.addEventListener('click', () => handleAnimeSelect(n)); i.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); handleAnimeSelect(n); } }); f.appendChild(i); }); resultsContainer.appendChild(f); resultsContainer.style.display = 'block'; if (episodeListContainer) episodeListContainer.style.display = 'none'; }
            function handleSearch() { if (!searchInput) return; const s = searchInput.value.trim().toLowerCase(); if (!allEpisodeRecords.length) { if (resultsContainer && s) resultsContainer.innerHTML = '<p class="placeholder-text error">Data chưa sẵn sàng.</p>'; else if (resultsContainer) resultsContainer.innerHTML = '<p class="placeholder-text">Nhập tên anime...</p>'; return; } if (!s) { if (resultsContainer) resultsContainer.innerHTML = '<p class="placeholder-text">Nhập tên anime...</p>'; if (episodeListContainer) episodeListContainer.style.display = 'none'; return; } const f = allEpisodeRecords.filter(r => r.animeName && r.animeName.toLowerCase().includes(s)); const u = [...new Set(f.map(r => r.animeName))]; renderSearchResults(u); }
            function handleAnimeSelect(name) { console.log(`✅ Selected: "${name}". Finding episodes...`); currentAnimeTitle = name; const episodes = allEpisodeRecords.filter(r => r.animeName === name); console.log(`🎞️ Found ${episodes.length} episode records.`); renderEpisodeList(episodes); if (resultsContainer) resultsContainer.style.display = 'none'; if (episodeListContainer) episodeListContainer.style.display = 'flex'; if (episodeListHeading) { episodeListHeading.textContent = currentAnimeTitle; episodeListHeading.style.display = 'block'; } if (backToSearchBtn) backToSearchBtn.style.display = 'inline-flex'; if (episodeListContainer) episodeListContainer.scrollTop = 0; }
            function renderEpisodeList(records) { if (!episodeListUl) return; episodeListUl.innerHTML = ''; if (!records || !records.length) { episodeListUl.innerHTML = '<li class="placeholder-text" style="border:none;background:none;text-align:center;width:100%;">Không có thông tin tập.</li>'; return; } const f = document.createDocumentFragment(); let validCount = 0; records.forEach(r => { const link = r.link?.trim(); const epName = r.episodeName?.trim(); const isValidLink = link && link !== '#' && link !== 'Không tìm thấy URL' && link.startsWith('http'); if (!epName) return; const i = document.createElement('li'); i.classList.add('episode-item'); i.textContent = epName; i.title = epName; i.dataset.episodeName = epName; if (isValidLink) { i.dataset.embedLink = link; i.setAttribute('role', 'button'); i.tabIndex = 0; i.addEventListener('click', () => handleEpisodePlay(link, epName)); i.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); handleEpisodePlay(link, epName); } }); } else { i.style.cssText = 'cursor:not-allowed; opacity:0.6; border-left-color: var(--color-text-secondary);'; i.title += ' (Link không khả dụng)'; } f.appendChild(i); validCount++; }); if (validCount === 0) { episodeListUl.innerHTML = '<li class="placeholder-text" style="border:none;background:none;text-align:center;width:100%;">Không tìm thấy tập hợp lệ.</li>'; } else { episodeListUl.appendChild(f); } }
            function handleEpisodePlay(link, epName) { console.log(`▶️ Playing Anime: "${currentAnimeTitle} - ${epName}"`); if (!playerContainer || !playerIframe || !playerTitle || !closePlayerBtn || !link || link === '#') { console.error("Anime Player/Link invalid."); return; } playerTitle.textContent = `${currentAnimeTitle} - ${epName}`; playerIframe.src = link; playerContainer.style.display = 'flex'; requestAnimationFrame(() => { playerContainer.classList.add('visible'); document.body.classList.add('player-open'); }); closePlayerBtn.focus(); }
            function closePlayer() { if (!playerContainer || !playerIframe || !playerContainer.classList.contains('visible')) return; playerContainer.classList.remove('visible'); document.body.classList.remove('player-open'); playerIframe.src = ''; const R = () => { if (!playerContainer.classList.contains('visible')) { playerContainer.style.display = ''; } playerContainer.removeEventListener('transitionend', R); }; playerContainer.addEventListener('transitionend', R); setTimeout(() => { if (!playerContainer.classList.contains('visible')) { playerContainer.style.display = ''; playerContainer.removeEventListener('transitionend', R); } }, 400); }
            function goBackToSearch() { if (resultsContainer) resultsContainer.style.display = 'block'; if (episodeListContainer) episodeListContainer.style.display = 'none'; if (backToSearchBtn) backToSearchBtn.style.display = 'none'; if (searchInput) { searchInput.focus(); handleSearch(); } }
            // ... (Hết phần logic Clock, Todo, Anime)

            // ============================
            // === INITIALIZATION ===
            // ============================
            function initializeProfile() {
                console.log("🚀 Init Profile v13.1 (Media Session)... ✨");
                setPrimaryColorRGB();
                if (clockElement) { updateClock(); clockInterval = setInterval(updateClock, 1000); }
                loadTasks();
                loadAnimeData();
                loadYouTubeAPI(); // Trigger YT API script load
                setupMediaSession(); // <-- Setup Media Session listeners

                // Init Music Player UI Listeners
                if (playPauseBtn) playPauseBtn.addEventListener('click', togglePlayPause);
                if (nextBtn) nextBtn.addEventListener('click', () => playNextTrack(false));
                if (prevBtn) prevBtn.addEventListener('click', playPrevTrack);

                // Initial player state setup
                if (playlist && playlist.length > 0) {
                    // Enable play button - It will load track 0 on first click if nothing is loaded
                    if (playPauseBtn) playPauseBtn.disabled = false;
                    updatePrevNextButtonStates();
                    if (trackTitleElement) trackTitleElement.textContent = "Sẵn sàng phát nhạc";
                } else {
                    if (trackTitleElement) trackTitleElement.textContent = "Playlist trống";
                    disableAllControls();
                }

                // Init Other UI Listeners
                if (searchInput) { searchInput.addEventListener('input', handleSearch); searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleSearch(); }); }
                if (searchButton) searchButton.addEventListener('click', () => { if (searchInput) searchInput.focus(); handleSearch(); });
                if (closePlayerBtn) closePlayerBtn.addEventListener('click', closePlayer);
                document.addEventListener('click', (e) => { if (document.body.classList.contains('player-open') && playerContainer && !playerContainer.contains(e.target) && !e.target.closest('.episode-item')) closePlayer(); });
                document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && playerContainer?.classList.contains('visible')) closePlayer(); });
                if (backToSearchBtn) backToSearchBtn.addEventListener('click', goBackToSearch);
                if (todoForm) todoForm.addEventListener('submit', addTask);
                if (requestPermissionBtn) requestPermissionBtn.addEventListener('click', handleRequestPermission);

                // --- Init Entrance Animations (No changes needed here) ---
                try {
                    if (typeof anime !== 'undefined') {
                        const tl = anime.timeline({ easing: 'easeOutExpo', duration: 800 });
                        tl.add({ targets: '#container', opacity: [0, 1], translateY: [20, 0], duration: 600 })
                            .add({ targets: ['#profile-image-wrapper', '#profile p#username'], opacity: [0, 1], scale: [.8, 1], duration: 600 }, '-=450')
                            .add({ targets: '#clock', opacity: [0, 1], translateY: [10, 0], duration: 400 }, '-=450')
                            .add({ targets: '#todo-section', opacity: [0, 1], translateY: [20, 0], duration: 500 }, '-=350') // Todo section appears first
                            .add({ targets: '#audio-player', opacity: [0, 1], translateY: [10, 0], duration: 500 }, '-=400') // Then audio player
                            .add({ targets: '#anime-search-section', opacity: [0, 1], translateY: [20, 0], duration: 500 }, '-=400') // Then anime search
                            .add({ targets: '#links li', opacity: [0, 1], translateX: [-20, 0], delay: anime.stagger(introStaggerDelay) }, '-=400')
                            .add({ targets: ['#social-links', 'footer'], opacity: [0, 1], translateY: [20, 0], duration: 500 }, '-=400');
                        if (glitchEffectOnLoad && usernameElement) tl.add({ targets: usernameElement, duration: 1, begin: () => { usernameElement.classList.add('glitch-text'); setTimeout(() => { usernameElement?.classList.remove('glitch-text') }, glitchDuration) } }, '-=300');

                        // Animate todo items after todo-section is visible
                        tl.finished.then(() => {
                            if (typeof anime !== 'undefined' && document.querySelectorAll('#todo-list li').length > 0) {
                                anime({ targets: '#todo-list li', opacity: [0, 1], translateX: [-10, 0], delay: anime.stagger(50), duration: 300, easing: 'easeOutQuad' });
                            }
                        });
                    } else { // Fallback if anime.js fails
                        document.querySelectorAll('#container,#profile,#clock,#todo-section,#audio-player,#anime-search-section,#links,#social-links,footer').forEach(el => { el.style.opacity = 1; el.style.transform = 'none'; });
                        renderTasks(); // Render todos without animation
                    }
                } catch (e) { // Catch potential errors during animation setup
                    console.error("Anim err:", e);
                    document.querySelectorAll('#container,#profile,#clock,#todo-section,#audio-player,#anime-search-section,#links,#social-links,footer').forEach(el => { el.style.opacity = 1; el.style.transform = 'none'; });
                    renderTasks();
                }

                // --- Init Hover Animations (No changes needed here) ---
                if (avatar) { avatar.addEventListener('mouseenter', () => anime({ targets: avatar, scale: 1.08, rotate: 4, duration: 300, easing: 'easeOutBack' })); avatar.addEventListener('mouseleave', () => anime({ targets: avatar, scale: 1, rotate: 0, duration: 400, easing: 'easeOutQuad' })); }
                Array.from(socialLinksContainer?.querySelectorAll('a') || []).forEach(l => { l.addEventListener('mouseenter', () => anime({ targets: l, translateY: -4, scale: 1.15, duration: 250, easing: 'easeOutBack' })); l.addEventListener('mouseleave', () => anime({ targets: l, translateY: 0, scale: 1, duration: 350, easing: 'easeOutQuad' })); });


                console.log("✅ Initialization v13.1 complete!");
                if (typeof anime !== 'undefined') console.log("ℹ️ Anime.js v:", anime.version);
                if (window.mediaSessionInterface) console.log("🎵 Media Session Interface Ready.");

            } // --- End initializeProfile ---

            // Run the initialization function
            initializeProfile();

        }); // --- DOMContentLoaded End ---
    </script>

</body>

</html>